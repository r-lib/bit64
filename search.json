[{"path":"https://bit64.r-lib.org/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Michael Chirico. Author, maintainer. Jens Oehlschlägel. Author. Leonardo Silvestri. Contributor. Ofek Shilon. Contributor.","code":""},{"path":"https://bit64.r-lib.org/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Chirico M, Oehlschlägel J (2025). bit64: S3 Class Vectors 64bit Integers. R package version 4.7.99, https://bit64.r-lib.org, https://github.com/r-lib/bit64.","code":"@Manual{,   title = {bit64: A S3 Class for Vectors of 64bit Integers},   author = {Michael Chirico and Jens Oehlschlägel},   year = {2025},   note = {R package version 4.7.99, https://bit64.r-lib.org},   url = {https://github.com/r-lib/bit64}, }"},{"path":"https://bit64.r-lib.org/index.html","id":"bit64","dir":"","previous_headings":"","what":"A S3 Class for Vectors of 64bit Integers","title":"A S3 Class for Vectors of 64bit Integers","text":"R package S3 Class Vectors 64bit Integers","code":""},{"path":"https://bit64.r-lib.org/reference/all.equal.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if two integer64 vectors are all.equal — all.equal.integer64","title":"Test if two integer64 vectors are all.equal — all.equal.integer64","text":"utility compare integer64 objects 'x' 'y' testing ‘near equality’, see .equal().","code":""},{"path":"https://bit64.r-lib.org/reference/all.equal.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if two integer64 vectors are all.equal — all.equal.integer64","text":"","code":"# S3 method for class 'integer64' all.equal(   target,   current,   tolerance = sqrt(.Machine$double.eps),   scale = NULL,   countEQ = FALSE,   formatFUN = function(err, what) format(err),   ...,   check.attributes = TRUE )"},{"path":"https://bit64.r-lib.org/reference/all.equal.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if two integer64 vectors are all.equal — all.equal.integer64","text":"target vector 'integer64' object can coerced .integer64() current vector 'integer64' object can coerced .integer64() tolerance numeric > 0.  Differences smaller tolerance reported.  default value close 1.5e-8. scale NULL numeric > 0, typically length 1 length(target). See Details. countEQ logical indicating target == current cases counted computing mean (absolute relative) differences. default, FALSE may seem misleading cases target current differ places; see extensive example. formatFUN function() two arguments, err, relative, absolute scaled error, , character string indicating kind error; maybe used, e.g., format relative absolute errors differently. ... arguments ignored check.attributes logical indicating attributes() target current (names) compared.","code":""},{"path":"https://bit64.r-lib.org/reference/all.equal.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if two integer64 vectors are all.equal — all.equal.integer64","text":"Either ‘TRUE’ (‘NULL’ ‘attr..equal’) vector ‘mode’ ‘\"character\"’ describing differences ‘target’ ‘current’.","code":""},{"path":"https://bit64.r-lib.org/reference/all.equal.integer64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test if two integer64 vectors are all.equal — all.equal.integer64","text":".equal.numeric() type integer treated proper subset double .e. complain comparing integer double. Following logic .equal.integer64 treats integer proper subset integer64 complain comparing integer integer64. double also compares without warning long values within lim.integer64(), double bigger .equal.integer64 complains .equal.integer64 overflow warning. details see .equal().","code":""},{"path":"https://bit64.r-lib.org/reference/all.equal.integer64.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Test if two integer64 vectors are all.equal — all.equal.integer64","text":".equal() dispatches method first argument integer64, calling .equal() non-integer64 first integer64 second argument gives undefined behavior!","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/all.equal.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test if two integer64 vectors are all.equal — all.equal.integer64","text":"","code":"all.equal(as.integer64(1:10), as.integer64(0:9)) #> [1] \"Mean relative difference: 0.1818182\"   all.equal(as.integer64(1:10), as.integer(1:10)) #> [1] TRUE   all.equal(as.integer64(1:10), as.double(1:10)) #> [1] TRUE   all.equal(as.integer64(1), as.double(1e300)) #> Error in as.integer64.double(current) :  #>   (converted from warning) NAs produced by integer64 overflow #> [1] \"while coercing 'current' to 'integer64': (converted from warning) NAs produced by integer64 overflow\""},{"path":"https://bit64.r-lib.org/reference/as.character.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce from integer64 — as.character.integer64","title":"Coerce from integer64 — as.character.integer64","text":"Methods coerce integer64 atomic types. '.bitstring' coerces human-readable bit representation (strings zeroes ones). methods format(), .character(), .double(), .logical(), .integer() expect.","code":""},{"path":"https://bit64.r-lib.org/reference/as.character.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce from integer64 — as.character.integer64","text":"","code":"as.bitstring(x, ...)  # S3 method for class 'integer64' as.double(x, keep.names = FALSE, ...)  # S3 method for class 'integer64' as.integer(x, ...)  # S3 method for class 'integer64' as.logical(x, ...)  # S3 method for class 'integer64' as.character(x, ...)  # S3 method for class 'integer64' as.bitstring(x, ...)  # S3 method for class 'bitstring' print(x, ...)  # S3 method for class 'integer64' as.list(x, ...)"},{"path":"https://bit64.r-lib.org/reference/as.character.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce from integer64 — as.character.integer64","text":"x integer64 vector ... arguments NextMethod() keep.names FALSE, set TRUE keep names vector","code":""},{"path":"https://bit64.r-lib.org/reference/as.character.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce from integer64 — as.character.integer64","text":".bitstring returns string class 'bitstring'. methods return atomic vectors expected types","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/as.character.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce from integer64 — as.character.integer64","text":"","code":"as.character(lim.integer64()) #> [1] \"-9223372036854775807\" \"9223372036854775807\"    as.bitstring(lim.integer64()) #> [1] \"1000000000000000000000000000000000000000000000000000000000000001\" #> [2] \"0111111111111111111111111111111111111111111111111111111111111111\"   as.bitstring(as.integer64(c(    -2,-1,NA,0:2   ))) #> [1] \"1111111111111111111111111111111111111111111111111111111111111110\" #> [2] \"1111111111111111111111111111111111111111111111111111111111111111\" #> [3] \"1000000000000000000000000000000000000000000000000000000000000000\" #> [4] \"0000000000000000000000000000000000000000000000000000000000000000\" #> [5] \"0000000000000000000000000000000000000000000000000000000000000001\" #> [6] \"0000000000000000000000000000000000000000000000000000000000000010\""},{"path":"https://bit64.r-lib.org/reference/as.data.frame.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"integer64: Coercing to data.frame column — as.data.frame.integer64","title":"integer64: Coercing to data.frame column — as.data.frame.integer64","text":"Coercing integer64 vector data.frame.","code":""},{"path":"https://bit64.r-lib.org/reference/as.data.frame.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"integer64: Coercing to data.frame column — as.data.frame.integer64","text":"","code":"# S3 method for class 'integer64' as.data.frame(x, ...)"},{"path":"https://bit64.r-lib.org/reference/as.data.frame.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"integer64: Coercing to data.frame column — as.data.frame.integer64","text":"x integer64 vector ... passed NextMethod .data.frame() removing 'integer64' class attribute","code":""},{"path":"https://bit64.r-lib.org/reference/as.data.frame.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"integer64: Coercing to data.frame column — as.data.frame.integer64","text":"one-column data.frame containing integer64 vector","code":""},{"path":"https://bit64.r-lib.org/reference/as.data.frame.integer64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"integer64: Coercing to data.frame column — as.data.frame.integer64","text":"'.data.frame.integer64' rather intended called directly, required allow integer64 data.frame columns.","code":""},{"path":"https://bit64.r-lib.org/reference/as.data.frame.integer64.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"integer64: Coercing to data.frame column — as.data.frame.integer64","text":"currently slow – ideas improvement?","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/as.data.frame.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"integer64: Coercing to data.frame column — as.data.frame.integer64","text":"","code":"as.data.frame.integer64(as.integer64(1:12)) #>     x #> 1   1 #> 2   2 #> 3   3 #> 4   4 #> 5   5 #> 6   6 #> 7   7 #> 8   8 #> 9   9 #> 10 10 #> 11 11 #> 12 12   data.frame(a=1:12, b=as.integer64(1:12)) #>     a  b #> 1   1  1 #> 2   2  2 #> 3   3  3 #> 4   4  4 #> 5   5  5 #> 6   6  6 #> 7   7  7 #> 8   8  8 #> 9   9  9 #> 10 10 10 #> 11 11 11 #> 12 12 12"},{"path":"https://bit64.r-lib.org/reference/as.integer64.character.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to integer64 — as.integer64.character","title":"Coerce to integer64 — as.integer64.character","text":"Methods coerce atomic types integer64.","code":""},{"path":"https://bit64.r-lib.org/reference/as.integer64.character.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to integer64 — as.integer64.character","text":"","code":"as.integer64(x, ...)  # S3 method for class '`NULL`' as.integer64(x, ...)  # S3 method for class 'integer64' as.integer64(x, ...)  # S3 method for class 'double' as.integer64(x, keep.names = FALSE, ...)  # S3 method for class 'integer' as.integer64(x, ...)  # S3 method for class 'logical' as.integer64(x, ...)  # S3 method for class 'character' as.integer64(x, ...)  # S3 method for class 'factor' as.integer64(x, ...)  # S3 method for class 'bitstring' as.integer64(x, ...)  NA_integer64_"},{"path":"https://bit64.r-lib.org/reference/as.integer64.character.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Coerce to integer64 — as.integer64.character","text":"object class integer64 length 1.","code":""},{"path":"https://bit64.r-lib.org/reference/as.integer64.character.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to integer64 — as.integer64.character","text":"x atomic vector ... arguments NextMethod() keep.names FALSE, set TRUE keep names vector","code":""},{"path":"https://bit64.r-lib.org/reference/as.integer64.character.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to integer64 — as.integer64.character","text":"methods return atomic vectors expected types","code":""},{"path":"https://bit64.r-lib.org/reference/as.integer64.character.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coerce to integer64 — as.integer64.character","text":".integer64.character realized using C function strtoll support scientific notation. Instead '1e6' use '1000000'. .integer64.bitstring evaluates characters '0' ' ' zero-bit, one byte characters one-bit, multi-byte characters allowed, strings shorter 64 characters treated left-padded '0', strings longer 64 bytes mapped NA_INTEGER64 warning emitted.","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/as.integer64.character.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to integer64 — as.integer64.character","text":"","code":"as.integer64(as.character(lim.integer64())) #> integer64 #> [1] -9223372036854775807 9223372036854775807  as.integer64(   structure(c(\"1111111111111111111111111111111111111111111111111111111111111110\",               \"1111111111111111111111111111111111111111111111111111111111111111\",               \"1000000000000000000000000000000000000000000000000000000000000000\",               \"0000000000000000000000000000000000000000000000000000000000000000\",               \"0000000000000000000000000000000000000000000000000000000000000001\",               \"0000000000000000000000000000000000000000000000000000000000000010\"   ), class = \"bitstring\") ) #> integer64 #> [1] -2   -1   <NA> 0    1    2    as.integer64(  structure(c(\"............................................................... \",              \"................................................................\",              \".                                                               \",              \"\",              \".\",              \"10\"   ), class = \"bitstring\") ) #> integer64 #> [1] -2   -1   <NA> 0    1    2"},{"path":"https://bit64.r-lib.org/reference/benchmark64.data.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit — benchmark64.data","title":"Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit — benchmark64.data","text":"results calling benchmark64()","code":""},{"path":"https://bit64.r-lib.org/reference/benchmark64.data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit — benchmark64.data","text":"","code":"data(benchmark64.data)"},{"path":"https://bit64.r-lib.org/reference/benchmark64.data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit — benchmark64.data","text":"format :","code":"num [1:16, 1:6] 2.55e-05 2.37 2.39 1.28 1.39 ... - attr(*, \"dimnames\")=List of 2 ..$ : chr [1:16] \"cache\" \"match(s,b)\" \"s %in% b\" \"match(b,s)\" ... ..$ : chr [1:6] \"32-bit\" \"64-bit\" \"hashcache\" \"sortordercache\" ..."},{"path":"https://bit64.r-lib.org/reference/benchmark64.data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit — benchmark64.data","text":"","code":"data(benchmark64.data) print(benchmark64.data) #>                     32-bit       64-bit    hashcache sortordercache #> cache         2.546532e-05 1.522116e-05  3.340000000   4.900000e+00 #> match(s,b)    2.370000e+00 6.300000e-01  0.004950495   3.785714e-02 #> s %in% b      2.390000e+00 6.700000e-01  0.004761905   3.333333e-02 #> match(b,s)    1.280000e+00 6.200000e-01  0.630000000   6.400000e-01 #> b %in% s      1.390000e+00 6.300000e-01  0.630000000   6.400000e-01 #> match(b,b)    7.020000e+00 3.860000e+00  2.260000000   4.230000e+00 #> b %in% b      7.420000e+00 3.790000e+00  2.200000000   4.130000e+00 #> duplicated(b) 2.620000e+00 2.090000e+00  0.500000000   6.100000e-01 #> unique(b)     2.860000e+00 2.090000e+00  1.830000000   7.500000e-01 #> table(b)      5.105700e+02 2.260000e+00  2.430000000   5.000000e-01 #> sort(b)       8.420000e+00 1.610000e+00  1.590000000   2.233333e-01 #> order(b)      5.349000e+01 2.590000e+00  2.540000000   1.120000e-01 #> rank(b)       5.614000e+01 3.200000e+00  3.280000000   9.000000e-01 #> quantile(b)   9.600000e-01 1.590000e+00  1.600000000   6.318348e-04 #> summary(b)    1.640000e+00 1.640000e+00  1.670000000   4.727273e-02 #> SESSION       8.499700e+02 3.680002e+01 33.954807692   2.131084e+01 #>                 ordercache     allcache #> cache         23.620000000 8.590000e+00 #> match(s,b)     0.166666667 4.950495e-03 #> s %in% b       0.170000000 4.761905e-03 #> match(b,s)     0.620000000 6.200000e-01 #> b %in% s       0.630000000 6.300000e-01 #> match(b,b)     4.260000000 2.280000e+00 #> b %in% b       4.180000000 2.210000e+00 #> duplicated(b)  1.760000000 6.000000e-01 #> unique(b)      1.890000000 1.820000e+00 #> table(b)       2.360000000 5.300000e-01 #> sort(b)        1.510000000 1.833333e-01 #> order(b)       0.083333333 9.333333e-02 #> rank(b)        2.910000000 9.200000e-01 #> quantile(b)    0.000618047 6.082725e-04 #> summary(b)     0.047272727 4.818182e-02 #> SESSION       49.277285479 2.187034e+01 matplot(log2(benchmark64.data[-1,1]/benchmark64.data[-1,]) , pch=c(\"3\", \"6\", \"h\", \"s\", \"o\", \"a\") , xlab=\"tasks [last=session]\" , ylab=\"log2(relative speed) [bigger is better]\" )  matplot(t(log2(benchmark64.data[-1,1]/benchmark64.data[-1,])) , axes=FALSE , type=\"b\" , lwd=c(rep(1, 14), 3) , xlab=\"context\" , ylab=\"log2(relative speed) [bigger is better]\" ) axis(1 , labels=c(\"32-bit\", \"64-bit\", \"hash\", \"sortorder\", \"order\", \"hash+sortorder\") , at=1:6 ) axis(2)"},{"path":"https://bit64.r-lib.org/reference/benchmark64.html","id":null,"dir":"Reference","previous_headings":"","what":"Function for measuring algorithmic performance of high-level and low-level integer64 functions — benchmark64","title":"Function for measuring algorithmic performance of high-level and low-level integer64 functions — benchmark64","text":"Function measuring algorithmic performance high-level low-level integer64 functions","code":""},{"path":"https://bit64.r-lib.org/reference/benchmark64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function for measuring algorithmic performance of high-level and low-level integer64 functions — benchmark64","text":"","code":"benchmark64(nsmall = 2L^16L, nbig = 2L^25L, timefun = repeat.time)  optimizer64(   nsmall = 2L^16L,   nbig = 2L^25L,   timefun = repeat.time,   what = c(\"match\", \"%in%\", \"duplicated\", \"unique\", \"unipos\", \"table\", \"rank\",     \"quantile\"),   uniorder = c(\"original\", \"values\", \"any\"),   taborder = c(\"values\", \"counts\"),   plot = TRUE )"},{"path":"https://bit64.r-lib.org/reference/benchmark64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function for measuring algorithmic performance of high-level and low-level integer64 functions — benchmark64","text":"nsmall size smaller vector nbig size larger bigger vector timefun function timing bit::repeat.time() system.time() vector names high-level functions uniorder one order parameters allowed unique.integer64() unipos.integer64() taborder one order parameters allowed table.integer64() plot set FALSE suppress plotting","code":""},{"path":"https://bit64.r-lib.org/reference/benchmark64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function for measuring algorithmic performance of high-level and low-level integer64 functions — benchmark64","text":"benchmark64 returns matrix elapsed seconds, different high-level tasks rows different scenarios solve task columns. last row named 'SESSION' contains elapsed seconds exemplary sesssion. optimizer64 returns dimensioned list one row high-level function timed two columns named values nsmall nbig sample sizes. list cell contains matrix timings, low-level-methods rows three measurements c(\"prep\",\"\",\"use\") columns. can measured separately, prep contains timing preparatory work sorting hashing, use contains timing using prepared work. function timed , preparation use, timing .","code":""},{"path":"https://bit64.r-lib.org/reference/benchmark64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function for measuring algorithmic performance of high-level and low-level integer64 functions — benchmark64","text":"benchmark64 compares following scenarios following use cases: Note timings cached variants contain time costs building cache, except timing exemplary user session, cache costs included order evaluate amortization.","code":""},{"path":"https://bit64.r-lib.org/reference/benchmark64.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Function for measuring algorithmic performance of high-level and low-level integer64 functions — benchmark64","text":"benchmark64(): compares high-level integer64 functions integer functions Base R optimizer64(): compares high-level integer64 function Base R integer function several low-level integer64 functions without caching","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/benchmark64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function for measuring algorithmic performance of high-level and low-level integer64 functions — benchmark64","text":"","code":"message(\"this small example using system.time does not give serious timings\\n this we do this only to run regression tests\") #> this small example using system.time does not give serious timings #>  #> this we do this only to run regression tests benchmark64(nsmall=2^7, nbig=2^13, timefun=function(expr)system.time(expr, gcFirst=FALSE)) #>  #> compare performance for a complete sessions of calls #>  #> === 32-bit === #> check data range, mean etc. #> get all percentiles for plotting distribution shape #> list the upper and lower permille of values #> OK, for some of these values I want to see the complete ROW, so I need their positions in the data.frame #> check if any values are duplicated #> since not unique, then check distribution of frequencies #> OK, let's plot the percentiles of unique values versus the percentiles allowing for duplicates #> check whether we find a match for each fact in the dimension table #> check whether there are any dimension table entries not in the fact table #> check whether we find a match for each fact in a parallel fact table #> find positions of facts in dimension table for joining #> find positions of facts in parallel fact table for joining #> out of curiosity: how well rank-correlated are fact and parallel fact table? #>         32-bit 64-bit hashcache sortordercache ordercache allcache #> seconds  0.009      0         0              0          0        0 #> factor   1.000    Inf       Inf            Inf        Inf      Inf #>  #> === 64-bit === #> check data range, mean etc. #> get all percentiles for plotting distribution shape #> list the upper and lower permille of values #> OK, for some of these values I want to see the complete ROW, so I need their positions in the data.frame #> check if any values are duplicated #> since not unique, then check distribution of frequencies #> OK, let's plot the percentiles of unique values versus the percentiles allowing for duplicates #> check whether we find a match for each fact in the dimension table #> check whether there are any dimension table entries not in the fact table #> check whether we find a match for each fact in a parallel fact table #> find positions of facts in dimension table for joining #> find positions of facts in parallel fact table for joining #> out of curiosity: how well rank-correlated are fact and parallel fact table? #>         32-bit 64-bit hashcache sortordercache ordercache allcache #> seconds  0.009  0.008         0              0          0        0 #> factor   1.000  1.125       Inf            Inf        Inf      Inf #>  #> === hashcache === #> check data range, mean etc. #> get all percentiles for plotting distribution shape #> list the upper and lower permille of values #> OK, for some of these values I want to see the complete ROW, so I need their positions in the data.frame #> check if any values are duplicated #> since not unique, then check distribution of frequencies #> OK, let's plot the percentiles of unique values versus the percentiles allowing for duplicates #> check whether we find a match for each fact in the dimension table #> check whether there are any dimension table entries not in the fact table #> check whether we find a match for each fact in a parallel fact table #> find positions of facts in dimension table for joining #> find positions of facts in parallel fact table for joining #> out of curiosity: how well rank-correlated are fact and parallel fact table? #>         32-bit 64-bit hashcache sortordercache ordercache allcache #> seconds  0.009  0.008     0.004              0          0        0 #> factor   1.000  1.125     2.250            Inf        Inf      Inf #>  #> === sortordercache === #> check data range, mean etc. #> get all percentiles for plotting distribution shape #> list the upper and lower permille of values #> OK, for some of these values I want to see the complete ROW, so I need their positions in the data.frame #> check if any values are duplicated #> since not unique, then check distribution of frequencies #> OK, let's plot the percentiles of unique values versus the percentiles allowing for duplicates #> check whether we find a match for each fact in the dimension table #> check whether there are any dimension table entries not in the fact table #> check whether we find a match for each fact in a parallel fact table #> find positions of facts in dimension table for joining #> find positions of facts in parallel fact table for joining #> out of curiosity: how well rank-correlated are fact and parallel fact table? #>         32-bit 64-bit hashcache sortordercache ordercache allcache #> seconds  0.009  0.008     0.004          0.003          0        0 #> factor   1.000  1.125     2.250          3.000        Inf      Inf #>  #> === ordercache === #> check data range, mean etc. #> get all percentiles for plotting distribution shape #> list the upper and lower permille of values #> OK, for some of these values I want to see the complete ROW, so I need their positions in the data.frame #> check if any values are duplicated #> since not unique, then check distribution of frequencies #> OK, let's plot the percentiles of unique values versus the percentiles allowing for duplicates #> check whether we find a match for each fact in the dimension table #> check whether there are any dimension table entries not in the fact table #> check whether we find a match for each fact in a parallel fact table #> find positions of facts in dimension table for joining #> find positions of facts in parallel fact table for joining #> out of curiosity: how well rank-correlated are fact and parallel fact table? #>         32-bit 64-bit hashcache sortordercache ordercache allcache #> seconds  0.009  0.008     0.004          0.003      0.016        0 #> factor   1.000  1.125     2.250          3.000      0.562      Inf #>  #> === allcache === #> check data range, mean etc. #> get all percentiles for plotting distribution shape #> list the upper and lower permille of values #> OK, for some of these values I want to see the complete ROW, so I need their positions in the data.frame #> check if any values are duplicated #> since not unique, then check distribution of frequencies #> OK, let's plot the percentiles of unique values versus the percentiles allowing for duplicates #> check whether we find a match for each fact in the dimension table #> check whether there are any dimension table entries not in the fact table #> check whether we find a match for each fact in a parallel fact table #> find positions of facts in dimension table for joining #> find positions of facts in parallel fact table for joining #> out of curiosity: how well rank-correlated are fact and parallel fact table? #>         32-bit 64-bit hashcache sortordercache ordercache allcache #> seconds  0.009  0.008     0.004          0.003      0.016    0.003 #> factor   1.000  1.125     2.250          3.000      0.562    3.000 #>  #> now let's look more systematically at the components involved #> 32-bit match(s,b) #> 32-bit s %in% b #> 32-bit match(b,s) #> 32-bit b %in% s #> 32-bit match(b,b) #> 32-bit b %in% b #> 32-bit duplicated(b) #> 32-bit unique(b) #> 32-bit table(b) #> 32-bit sort(b) #> 32-bit order(b) #> 32-bit rank(b) #> 32-bit quantile(b) #> 32-bit summary(b) #> seconds              32-bit 64-bit hashcache sortordercache ordercache allcache #> cache          0.000  0.000     0.000          0.000      0.000    0.000 #> match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000 #> s %in% b       0.000  0.000     0.000          0.000      0.000    0.000 #> match(b,s)     0.000  0.000     0.000          0.000      0.000    0.000 #> b %in% s       0.000  0.000     0.000          0.000      0.000    0.000 #> match(b,b)     0.000  0.000     0.000          0.000      0.000    0.000 #> b %in% b       0.001  0.000     0.000          0.000      0.000    0.000 #> duplicated(b)  0.000  0.000     0.000          0.000      0.000    0.000 #> unique(b)      0.001  0.000     0.000          0.000      0.000    0.000 #> table(b)       0.003  0.000     0.000          0.000      0.000    0.000 #> sort(b)        0.000  0.000     0.000          0.000      0.000    0.000 #> order(b)       0.000  0.000     0.000          0.000      0.000    0.000 #> rank(b)        0.001  0.000     0.000          0.000      0.000    0.000 #> quantile(b)    0.000  0.000     0.000          0.000      0.000    0.000 #> summary(b)     0.000  0.000     0.000          0.000      0.000    0.000 #> SESSION        0.009  0.008     0.004          0.003      0.016    0.003 #> factor              32-bit 64-bit hashcache sortordercache ordercache allcache #> cache            NaN    NaN       NaN            NaN        NaN      NaN #> match(s,b)       NaN    NaN       NaN            NaN        NaN      NaN #> s %in% b         NaN    NaN       NaN            NaN        NaN      NaN #> match(b,s)       NaN    NaN       NaN            NaN        NaN      NaN #> b %in% s         NaN    NaN       NaN            NaN        NaN      NaN #> match(b,b)       NaN    NaN       NaN            NaN        NaN      NaN #> b %in% b           1    Inf       Inf            Inf        Inf      Inf #> duplicated(b)    NaN    NaN       NaN            NaN        NaN      NaN #> unique(b)          1    Inf       Inf            Inf        Inf      Inf #> table(b)           1    Inf       Inf            Inf        Inf      Inf #> sort(b)          NaN    NaN       NaN            NaN        NaN      NaN #> order(b)         NaN    NaN       NaN            NaN        NaN      NaN #> rank(b)            1    Inf       Inf            Inf        Inf      Inf #> quantile(b)      NaN    NaN       NaN            NaN        NaN      NaN #> summary(b)       NaN    NaN       NaN            NaN        NaN      NaN #> SESSION            1  1.125      2.25              3      0.562        3 #> 64-bit match(s,b) #> 64-bit s %in% b #> 64-bit match(b,s) #> 64-bit b %in% s #> 64-bit match(b,b) #> 64-bit b %in% b #> 64-bit duplicated(b) #> 64-bit unique(b) #> 64-bit table(b) #> 64-bit sort(b) #> 64-bit order(b) #> 64-bit rank(b) #> 64-bit quantile(b) #> 64-bit summary(b) #> seconds              32-bit 64-bit hashcache sortordercache ordercache allcache #> cache          0.000  0.000     0.000          0.000      0.000    0.000 #> match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000 #> s %in% b       0.000  0.000     0.000          0.000      0.000    0.000 #> match(b,s)     0.000  0.000     0.000          0.000      0.000    0.000 #> b %in% s       0.000  0.000     0.000          0.000      0.000    0.000 #> match(b,b)     0.000  0.001     0.000          0.000      0.000    0.000 #> b %in% b       0.001  0.000     0.000          0.000      0.000    0.000 #> duplicated(b)  0.000  0.001     0.000          0.000      0.000    0.000 #> unique(b)      0.001  0.000     0.000          0.000      0.000    0.000 #> table(b)       0.003  0.000     0.000          0.000      0.000    0.000 #> sort(b)        0.000  0.000     0.000          0.000      0.000    0.000 #> order(b)       0.000  0.000     0.000          0.000      0.000    0.000 #> rank(b)        0.001  0.000     0.000          0.000      0.000    0.000 #> quantile(b)    0.000  0.000     0.000          0.000      0.000    0.000 #> summary(b)     0.000  0.000     0.000          0.000      0.000    0.000 #> SESSION        0.009  0.008     0.004          0.003      0.016    0.003 #> factor              32-bit 64-bit hashcache sortordercache ordercache allcache #> cache            NaN    NaN       NaN            NaN        NaN      NaN #> match(s,b)       NaN    NaN       NaN            NaN        NaN      NaN #> s %in% b         NaN    NaN       NaN            NaN        NaN      NaN #> match(b,s)       NaN    NaN       NaN            NaN        NaN      NaN #> b %in% s         NaN    NaN       NaN            NaN        NaN      NaN #> match(b,b)       NaN  0.000       NaN            NaN        NaN      NaN #> b %in% b           1    Inf       Inf            Inf        Inf      Inf #> duplicated(b)    NaN  0.000       NaN            NaN        NaN      NaN #> unique(b)          1    Inf       Inf            Inf        Inf      Inf #> table(b)           1    Inf       Inf            Inf        Inf      Inf #> sort(b)          NaN    NaN       NaN            NaN        NaN      NaN #> order(b)         NaN    NaN       NaN            NaN        NaN      NaN #> rank(b)            1    Inf       Inf            Inf        Inf      Inf #> quantile(b)      NaN    NaN       NaN            NaN        NaN      NaN #> summary(b)       NaN    NaN       NaN            NaN        NaN      NaN #> SESSION            1  1.125      2.25              3      0.562        3 #> hashcache cache #> hashcache match(s,b) #> hashcache s %in% b #> hashcache match(b,s) #> hashcache b %in% s #> hashcache match(b,b) #> hashcache b %in% b #> hashcache duplicated(b) #> hashcache unique(b) #> hashcache table(b) #> hashcache sort(b) #> hashcache order(b) #> hashcache rank(b) #> hashcache quantile(b) #> hashcache summary(b) #> seconds              32-bit 64-bit hashcache sortordercache ordercache allcache #> cache          0.000  0.000     0.000          0.000      0.000    0.000 #> match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000 #> s %in% b       0.000  0.000     0.001          0.000      0.000    0.000 #> match(b,s)     0.000  0.000     0.000          0.000      0.000    0.000 #> b %in% s       0.000  0.000     0.000          0.000      0.000    0.000 #> match(b,b)     0.000  0.001     0.000          0.000      0.000    0.000 #> b %in% b       0.001  0.000     0.000          0.000      0.000    0.000 #> duplicated(b)  0.000  0.001     0.000          0.000      0.000    0.000 #> unique(b)      0.001  0.000     0.000          0.000      0.000    0.000 #> table(b)       0.003  0.000     0.000          0.000      0.000    0.000 #> sort(b)        0.000  0.000     0.001          0.000      0.000    0.000 #> order(b)       0.000  0.000     0.000          0.000      0.000    0.000 #> rank(b)        0.001  0.000     0.001          0.000      0.000    0.000 #> quantile(b)    0.000  0.000     0.000          0.000      0.000    0.000 #> summary(b)     0.000  0.000     0.001          0.000      0.000    0.000 #> SESSION        0.009  0.008     0.004          0.003      0.016    0.003 #> factor              32-bit 64-bit hashcache sortordercache ordercache allcache #> cache            NaN    NaN       NaN            NaN        NaN      NaN #> match(s,b)       NaN    NaN       NaN            NaN        NaN      NaN #> s %in% b         NaN    NaN      0.00            NaN        NaN      NaN #> match(b,s)       NaN    NaN       NaN            NaN        NaN      NaN #> b %in% s         NaN    NaN       NaN            NaN        NaN      NaN #> match(b,b)       NaN  0.000       NaN            NaN        NaN      NaN #> b %in% b           1    Inf       Inf            Inf        Inf      Inf #> duplicated(b)    NaN  0.000       NaN            NaN        NaN      NaN #> unique(b)          1    Inf       Inf            Inf        Inf      Inf #> table(b)           1    Inf       Inf            Inf        Inf      Inf #> sort(b)          NaN    NaN      0.00            NaN        NaN      NaN #> order(b)         NaN    NaN       NaN            NaN        NaN      NaN #> rank(b)            1    Inf      1.00            Inf        Inf      Inf #> quantile(b)      NaN    NaN       NaN            NaN        NaN      NaN #> summary(b)       NaN    NaN      0.00            NaN        NaN      NaN #> SESSION            1  1.125      2.25              3      0.562        3 #> sortordercache cache #> sortordercache match(s,b) #> sortordercache s %in% b #> sortordercache match(b,s) #> sortordercache b %in% s #> sortordercache match(b,b) #> sortordercache b %in% b #> sortordercache duplicated(b) #> sortordercache unique(b) #> sortordercache table(b) #> sortordercache sort(b) #> sortordercache order(b) #> sortordercache rank(b) #> sortordercache quantile(b) #> sortordercache summary(b) #> seconds              32-bit 64-bit hashcache sortordercache ordercache allcache #> cache          0.000  0.000     0.000          0.000      0.000    0.000 #> match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000 #> s %in% b       0.000  0.000     0.001          0.000      0.000    0.000 #> match(b,s)     0.000  0.000     0.000          0.000      0.000    0.000 #> b %in% s       0.000  0.000     0.000          0.000      0.000    0.000 #> match(b,b)     0.000  0.001     0.000          0.000      0.000    0.000 #> b %in% b       0.001  0.000     0.000          0.000      0.000    0.000 #> duplicated(b)  0.000  0.001     0.000          0.000      0.000    0.000 #> unique(b)      0.001  0.000     0.000          0.001      0.000    0.000 #> table(b)       0.003  0.000     0.000          0.000      0.000    0.000 #> sort(b)        0.000  0.000     0.001          0.000      0.000    0.000 #> order(b)       0.000  0.000     0.000          0.000      0.000    0.000 #> rank(b)        0.001  0.000     0.001          0.000      0.000    0.000 #> quantile(b)    0.000  0.000     0.000          0.001      0.000    0.000 #> summary(b)     0.000  0.000     0.001          0.000      0.000    0.000 #> SESSION        0.009  0.008     0.004          0.003      0.016    0.003 #> factor              32-bit 64-bit hashcache sortordercache ordercache allcache #> cache            NaN    NaN       NaN            NaN        NaN      NaN #> match(s,b)       NaN    NaN       NaN            NaN        NaN      NaN #> s %in% b         NaN    NaN      0.00            NaN        NaN      NaN #> match(b,s)       NaN    NaN       NaN            NaN        NaN      NaN #> b %in% s         NaN    NaN       NaN            NaN        NaN      NaN #> match(b,b)       NaN  0.000       NaN            NaN        NaN      NaN #> b %in% b           1    Inf       Inf            Inf        Inf      Inf #> duplicated(b)    NaN  0.000       NaN            NaN        NaN      NaN #> unique(b)          1    Inf       Inf              1        Inf      Inf #> table(b)           1    Inf       Inf            Inf        Inf      Inf #> sort(b)          NaN    NaN      0.00            NaN        NaN      NaN #> order(b)         NaN    NaN       NaN            NaN        NaN      NaN #> rank(b)            1    Inf      1.00            Inf        Inf      Inf #> quantile(b)      NaN    NaN       NaN              0        NaN      NaN #> summary(b)       NaN    NaN      0.00            NaN        NaN      NaN #> SESSION            1  1.125      2.25              3      0.562        3 #> ordercache cache #> ordercache match(s,b) #> ordercache s %in% b #> ordercache match(b,s) #> ordercache b %in% s #> ordercache match(b,b) #> ordercache b %in% b #> ordercache duplicated(b) #> ordercache unique(b) #> ordercache table(b) #> ordercache sort(b) #> ordercache order(b) #> ordercache rank(b) #> ordercache quantile(b) #> ordercache summary(b) #> seconds              32-bit 64-bit hashcache sortordercache ordercache allcache #> cache          0.000  0.000     0.000          0.000      0.001    0.000 #> match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000 #> s %in% b       0.000  0.000     0.001          0.000      0.000    0.000 #> match(b,s)     0.000  0.000     0.000          0.000      0.001    0.000 #> b %in% s       0.000  0.000     0.000          0.000      0.000    0.000 #> match(b,b)     0.000  0.001     0.000          0.000      0.001    0.000 #> b %in% b       0.001  0.000     0.000          0.000      0.000    0.000 #> duplicated(b)  0.000  0.001     0.000          0.000      0.000    0.000 #> unique(b)      0.001  0.000     0.000          0.001      0.000    0.000 #> table(b)       0.003  0.000     0.000          0.000      0.000    0.000 #> sort(b)        0.000  0.000     0.001          0.000      0.000    0.000 #> order(b)       0.000  0.000     0.000          0.000      0.000    0.000 #> rank(b)        0.001  0.000     0.001          0.000      0.001    0.000 #> quantile(b)    0.000  0.000     0.000          0.001      0.000    0.000 #> summary(b)     0.000  0.000     0.001          0.000      0.001    0.000 #> SESSION        0.009  0.008     0.004          0.003      0.016    0.003 #> factor              32-bit 64-bit hashcache sortordercache ordercache allcache #> cache            NaN    NaN       NaN            NaN      0.000      NaN #> match(s,b)       NaN    NaN       NaN            NaN        NaN      NaN #> s %in% b         NaN    NaN      0.00            NaN        NaN      NaN #> match(b,s)       NaN    NaN       NaN            NaN      0.000      NaN #> b %in% s         NaN    NaN       NaN            NaN        NaN      NaN #> match(b,b)       NaN  0.000       NaN            NaN      0.000      NaN #> b %in% b           1    Inf       Inf            Inf        Inf      Inf #> duplicated(b)    NaN  0.000       NaN            NaN        NaN      NaN #> unique(b)          1    Inf       Inf              1        Inf      Inf #> table(b)           1    Inf       Inf            Inf        Inf      Inf #> sort(b)          NaN    NaN      0.00            NaN        NaN      NaN #> order(b)         NaN    NaN       NaN            NaN        NaN      NaN #> rank(b)            1    Inf      1.00            Inf      1.000      Inf #> quantile(b)      NaN    NaN       NaN              0        NaN      NaN #> summary(b)       NaN    NaN      0.00            NaN      0.000      NaN #> SESSION            1  1.125      2.25              3      0.562        3 #> allcache cache #> allcache match(s,b) #> allcache s %in% b #> allcache match(b,s) #> allcache b %in% s #> allcache match(b,b) #> allcache b %in% b #> allcache duplicated(b) #> allcache unique(b) #> allcache table(b) #> allcache sort(b) #> allcache order(b) #> allcache rank(b) #> allcache quantile(b) #> allcache summary(b) #> seconds              32-bit 64-bit hashcache sortordercache ordercache allcache #> cache          0.000  0.000     0.000          0.000      0.001    0.001 #> match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000 #> s %in% b       0.000  0.000     0.001          0.000      0.000    0.000 #> match(b,s)     0.000  0.000     0.000          0.000      0.001    0.000 #> b %in% s       0.000  0.000     0.000          0.000      0.000    0.000 #> match(b,b)     0.000  0.001     0.000          0.000      0.001    0.000 #> b %in% b       0.001  0.000     0.000          0.000      0.000    0.000 #> duplicated(b)  0.000  0.001     0.000          0.000      0.000    0.000 #> unique(b)      0.001  0.000     0.000          0.001      0.000    0.000 #> table(b)       0.003  0.000     0.000          0.000      0.000    0.000 #> sort(b)        0.000  0.000     0.001          0.000      0.000    0.000 #> order(b)       0.000  0.000     0.000          0.000      0.000    0.000 #> rank(b)        0.001  0.000     0.001          0.000      0.001    0.000 #> quantile(b)    0.000  0.000     0.000          0.001      0.000    0.000 #> summary(b)     0.000  0.000     0.001          0.000      0.001    0.000 #> SESSION        0.009  0.008     0.004          0.003      0.016    0.003 #> factor              32-bit 64-bit hashcache sortordercache ordercache allcache #> cache            NaN    NaN       NaN            NaN      0.000        0 #> match(s,b)       NaN    NaN       NaN            NaN        NaN      NaN #> s %in% b         NaN    NaN      0.00            NaN        NaN      NaN #> match(b,s)       NaN    NaN       NaN            NaN      0.000      NaN #> b %in% s         NaN    NaN       NaN            NaN        NaN      NaN #> match(b,b)       NaN  0.000       NaN            NaN      0.000      NaN #> b %in% b           1    Inf       Inf            Inf        Inf      Inf #> duplicated(b)    NaN  0.000       NaN            NaN        NaN      NaN #> unique(b)          1    Inf       Inf              1        Inf      Inf #> table(b)           1    Inf       Inf            Inf        Inf      Inf #> sort(b)          NaN    NaN      0.00            NaN        NaN      NaN #> order(b)         NaN    NaN       NaN            NaN        NaN      NaN #> rank(b)            1    Inf      1.00            Inf      1.000      Inf #> quantile(b)      NaN    NaN       NaN              0        NaN      NaN #> summary(b)       NaN    NaN      0.00            NaN      0.000      NaN #> SESSION            1  1.125      2.25              3      0.562        3 #>               32-bit 64-bit hashcache sortordercache ordercache allcache #> cache          0.000  0.000     0.000          0.000      0.001    0.001 #> match(s,b)     0.000  0.000     0.000          0.000      0.000    0.000 #> s %in% b       0.000  0.000     0.001          0.000      0.000    0.000 #> match(b,s)     0.000  0.000     0.000          0.000      0.001    0.000 #> b %in% s       0.000  0.000     0.000          0.000      0.000    0.000 #> match(b,b)     0.000  0.001     0.000          0.000      0.001    0.000 #> b %in% b       0.001  0.000     0.000          0.000      0.000    0.000 #> duplicated(b)  0.000  0.001     0.000          0.000      0.000    0.000 #> unique(b)      0.001  0.000     0.000          0.001      0.000    0.000 #> table(b)       0.003  0.000     0.000          0.000      0.000    0.000 #> sort(b)        0.000  0.000     0.001          0.000      0.000    0.000 #> order(b)       0.000  0.000     0.000          0.000      0.000    0.000 #> rank(b)        0.001  0.000     0.001          0.000      0.001    0.000 #> quantile(b)    0.000  0.000     0.000          0.001      0.000    0.000 #> summary(b)     0.000  0.000     0.001          0.000      0.001    0.000 #> SESSION        0.009  0.008     0.004          0.003      0.016    0.003 optimizer64(nsmall=2^7, nbig=2^13, timefun=function(expr)system.time(expr, gcFirst=FALSE) , plot=FALSE ) #> match: timings of different methods #> %in%: timings of different methods #> duplicated: timings of different methods #> unique: timings of different methods #> unipos: timings of different methods #> table: timings of different methods #> rank: timings of different methods #> quantile: timings of different methods #>            128        8192       #> match      numeric,27 numeric,27 #> %in%       numeric,30 numeric,30 #> duplicated numeric,30 numeric,30 #> unique     numeric,45 numeric,45 #> unipos     numeric,42 numeric,42 #> table      numeric,39 numeric,39 #> rank       numeric,21 numeric,21 #> quantile   numeric,18 numeric,18 if (FALSE) { # \\dontrun{ message(\"for real measurement of sufficiently large datasets run this on your machine\") benchmark64() optimizer64() } # } message(\"let's look at the performance results on Core i7 Lenovo T410 with 8 GB RAM\") #> let's look at the performance results on Core i7 Lenovo T410 with 8 GB RAM data(benchmark64.data) print(benchmark64.data) #>                     32-bit       64-bit    hashcache sortordercache #> cache         2.546532e-05 1.522116e-05  3.340000000   4.900000e+00 #> match(s,b)    2.370000e+00 6.300000e-01  0.004950495   3.785714e-02 #> s %in% b      2.390000e+00 6.700000e-01  0.004761905   3.333333e-02 #> match(b,s)    1.280000e+00 6.200000e-01  0.630000000   6.400000e-01 #> b %in% s      1.390000e+00 6.300000e-01  0.630000000   6.400000e-01 #> match(b,b)    7.020000e+00 3.860000e+00  2.260000000   4.230000e+00 #> b %in% b      7.420000e+00 3.790000e+00  2.200000000   4.130000e+00 #> duplicated(b) 2.620000e+00 2.090000e+00  0.500000000   6.100000e-01 #> unique(b)     2.860000e+00 2.090000e+00  1.830000000   7.500000e-01 #> table(b)      5.105700e+02 2.260000e+00  2.430000000   5.000000e-01 #> sort(b)       8.420000e+00 1.610000e+00  1.590000000   2.233333e-01 #> order(b)      5.349000e+01 2.590000e+00  2.540000000   1.120000e-01 #> rank(b)       5.614000e+01 3.200000e+00  3.280000000   9.000000e-01 #> quantile(b)   9.600000e-01 1.590000e+00  1.600000000   6.318348e-04 #> summary(b)    1.640000e+00 1.640000e+00  1.670000000   4.727273e-02 #> SESSION       8.499700e+02 3.680002e+01 33.954807692   2.131084e+01 #>                 ordercache     allcache #> cache         23.620000000 8.590000e+00 #> match(s,b)     0.166666667 4.950495e-03 #> s %in% b       0.170000000 4.761905e-03 #> match(b,s)     0.620000000 6.200000e-01 #> b %in% s       0.630000000 6.300000e-01 #> match(b,b)     4.260000000 2.280000e+00 #> b %in% b       4.180000000 2.210000e+00 #> duplicated(b)  1.760000000 6.000000e-01 #> unique(b)      1.890000000 1.820000e+00 #> table(b)       2.360000000 5.300000e-01 #> sort(b)        1.510000000 1.833333e-01 #> order(b)       0.083333333 9.333333e-02 #> rank(b)        2.910000000 9.200000e-01 #> quantile(b)    0.000618047 6.082725e-04 #> summary(b)     0.047272727 4.818182e-02 #> SESSION       49.277285479 2.187034e+01  matplot(log2(benchmark64.data[-1,1]/benchmark64.data[-1,]) , pch=c(\"3\", \"6\", \"h\", \"s\", \"o\", \"a\") , xlab=\"tasks [last=session]\" , ylab=\"log2(relative speed) [bigger is better]\" )  matplot(t(log2(benchmark64.data[-1,1]/benchmark64.data[-1,])) , type=\"b\", axes=FALSE , lwd=c(rep(1, 14), 3) , xlab=\"context\" , ylab=\"log2(relative speed) [bigger is better]\" ) axis(1 , labels=c(\"32-bit\", \"64-bit\", \"hash\", \"sortorder\", \"order\", \"hash+sortorder\") , at=1:6 ) axis(2)  data(optimizer64.data) print(optimizer64.data) #>            65536      33554432   #> match      numeric,27 numeric,27 #> %in%       numeric,30 numeric,30 #> duplicated numeric,30 numeric,30 #> unique     numeric,45 numeric,45 #> unipos     numeric,42 numeric,42 #> table      numeric,39 numeric,39 #> rank       numeric,21 numeric,21 #> quantile   numeric,18 numeric,18 oldpar <- par(no.readonly = TRUE) par(mfrow=c(2,1)) par(cex=0.7) for (i in 1:nrow(optimizer64.data)){  for (j in 1:2){    tim <- optimizer64.data[[i,j]]   barplot(t(tim))   if (rownames(optimizer64.data)[i]==\"match\")    title(paste(\"match\", colnames(optimizer64.data)[j], \"in\", colnames(optimizer64.data)[3-j]))   else if (rownames(optimizer64.data)[i]==\"%in%\")    title(paste(colnames(optimizer64.data)[j], \"%in%\", colnames(optimizer64.data)[3-j]))   else    title(paste(rownames(optimizer64.data)[i], colnames(optimizer64.data)[j]))  } }         par(mfrow=c(1,1))"},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":null,"dir":"Reference","previous_headings":"","what":"A S3 class for vectors of 64bit integers — bit64-package","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"Package 'bit64' provides fast serializable S3 atomic 64bit (signed) integers can used vectors, matrices, arrays data.frames. Methods available coercion logicals, integers, doubles, characters factors well many elementwise summary functions.","code":""},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"version-","dir":"Reference","previous_headings":"","what":"Version 0.8","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"'integer64' vectors can store large integers expense 64 bits, factor 7 better 'int64' package 'int64'. Due smaller memory footprint, atomic vector architecture using S3 instead S4 classes, operations one three orders magnitude faster: Example speedups 4x serialization, 250x adding, 900x coercion 2000x object creation. Also 'integer64' avoids ongoing (potentially infinite) penalty garbage collection observed existence 'int64' objects (see code example section).","code":""},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"version--1","dir":"Reference","previous_headings":"","what":"Version 0.9","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"Package 'bit64' - extends R fast 64-bit integers - now fast (single-threaded) implementations important univariate algorithmic operations (based hashing sorting). now methods 'match', '%%', 'duplicated', 'unique', 'table', 'sort', 'order', 'rank', 'quantile', 'median' 'summary'. Regarding data management also novel generics 'unipos' (positions unique values), 'tiepos' ( positions ties), 'keypos' (positions foreign keys sorted dimension table) derived methods '.factor' '.ordered'. 64- bit functionality implemented carefully slower respective 32-bit operations Base R also avoid outlying waiting times observed 'order', 'rank' 'table' (speedup factors 20/16/200 respective). increases dataset size wich can work truly interactive. speed achieved simple heuristic optimizers high- level functions choosing best multiple low-level algorithms taking advantage novel caching activated. example R session using couple operations 64-bit integers performed 22x faster base 32-bit integers, hash-caching improved 24x, sortorder-caching efficient 38x (caching hashing sorting worth 32x duplicated RAM consumption).","code":""},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"","code":"integer64(length = 0L)  is.integer64(x)  # S3 method for class 'integer64' length(x) <- value  # S3 method for class 'integer64' print(x, quote = FALSE, ...)  # S3 method for class 'integer64' str(   object,   vec.len = strO$vec.len,   give.head = TRUE,   give.length = give.head,   ... )"},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"length length vector using integer() x integer64 vector value integer64 vector values assigned quote logical, indicating whether strings printed surrounding quotes. ... arguments NextMethod() object integer64 vector vec.len, give.head, give.length see utils::str()","code":""},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"integer64 returns vector 'integer64', .e., vector double() decorated class 'integer64'.","code":""},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"integer64 useful handling database keys exact counting +-2^63. use replacement 32bit integers, integer64 supported subscripting R-core different semantics combined double. understand integer64 can useful double coerce double. integer + double -> double + double -> double 1L + 0.5 -> 1.5 additive operations coerce integer64 integer64 + double ->  integer64 + integer64 -> integer64 hence .integer64(1) + 0.5 -> 1LL + 0LL -> 1LL see section \"Arithmetic precision coercion\" ","code":""},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"design-considerations","dir":"Reference","previous_headings":"","what":"Design considerations","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"64 bit integers related big data: need overcome address space limitations. Therefore performance 64 bit integer type critical. S language – designed 1975 – atomic objects defined vectors couple good reasons: simplicity, option implicit parallelization, good cache locality. recent years many analytical databases learnt lesson: column based data bases provide superior performance many applications, result products MonetDB, Sybase IQ, Vertica, Exasol, Ingres Vectorwise. introduce 64 bit integers natively Base R external package, least strive make 'basic' possible. Therefore design choice bit64 differs package int64, obvious: Like atomic types Base R, model data type 'integer64' contiguous atomic vector memory, use basic S3 class system, S4. Like package int64 want 'integer64' serializeable, therefore also use existing data type basis. choice obvious: R one 64 bit data type: doubles. using doubles, integer64 inherits functionality .atomic(), length(), length<-, names(), names<-, dim(), dim<-, dimnames(), dimnames<-. R level functions strictly follow functional programming paradigm: modification arguments side-effects. version 0.93  internally deviated strict paradigm order boost performance. C functions create new return values, instead pass-memory returned argument. gives us freedom apply C-function new old vectors, helps avoid unnecessary memory allocation, unnecessary copying unnecessary garbage collection. Prior 0.93 within R functions also deviated conventional R programming using attr<- attributes<- always new memory allocation copying older R versions. wanted set attributes return values freshly created, instead used functions bit::setattr() bit::setattributes(). version 0.93 bit::setattr() used manipulating cache objects, ramsort.integer64(), sort.integer64(), .data.frame.integer64().","code":""},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"arithmetic-precision-and-coercion","dir":"Reference","previous_headings":"","what":"Arithmetic precision and coercion","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"fact introduce 64 bit long long integers – without introducing 128-bit long doubles – creates subtle challenges: Unlike 32 bit integers, integer64 longer proper subset double. binary arithmetic operation involve double integer, -brainer return double without loss information. integer64 meets double, trivial type return. Switching integer64 limits ability represent large numbers, switching double limits ability distinguish x x+1. Since latter purpose introducing 64 bit integers, usually return integer64 functions involving integer64, example c(), cbind(), rbind() Different Base R, operators +, -, %/%, %% coerce arguments integer64 always return integer64. multiplication operator * coerces first argument integer64 allows second argument also double: second argument internaly coerced 'long double' result multiplication returned integer64. division / power ^ operators also coerce first argument integer64 coerce internally second argument 'long double', return double, like sqrt(), log(), log2(), log10() .","code":""},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"creating-and-testing-s-class-integer-","dir":"Reference","previous_headings":"","what":"Creating and testing S3 class 'integer64'","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"creator function integer64 takes argument length, creates atomic double vector length, attaches S3 class attribute 'integer64' , . simply rely S3 method dispatch interpret 64-bit elements 'long long int'. .double() currently returns TRUE integer64 might return FALSE later release. Consider .double() undefined behavior query .integer64() querying .double(). methods .integer64() .vector() return TRUE integer64. Note patch storage.mode() typeof(), continue returning 'double'. Like 32 bit integer, mode() returns 'numeric' .double() tries coercing double. possible 'integer64' becomes vmode package ff. methods creating integer64 range() returns range data type calles without arguments, rep(), seq(). available methods integer64 vectors see index examples.","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"limitations-inherited-from-implementing-bit-integers-via-an-external-package","dir":"Reference","previous_headings":"","what":"Limitations inherited from implementing 64 bit integers via an external package","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"vector size atomic vectors still limited .Machine$integer.max. However, external memory extending packages ff bigmemory can extend address space now integer64. 64 bit integers also help obvious address issues arise exchange data SQL databases datawarehouses, use big integers surrogate keys, e.g. indexed primary key columns. puts R relatively strong position compared certain commercial statistical softwares, sell database connectivity neither range 64 bit integers, integers , single numeric data type macro-glue-language. literals 123LL require changes Base R, need write (call) .integer64(123L) .integer64(123) .integer64('123'). latter allows specify numbers beyond Base R's numeric data types therefore recommended way use – using one way may facilitate migrating code literals later stage.","code":""},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"limitations-inherited-from-base-r-core-team-can-you-change-this-","dir":"Reference","previous_headings":"","what":"Limitations inherited from Base R, Core team, can you change this?","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"identical() default parameters distinguish bit-patterns doubles. testing purposes provide wrapper identical.integer64() distinguish bit-patterns. desireable single call identical() handle , double integer64. colon operator : officially dispatch S3 methods, however, made generic:   limitation remains: dispatch first argument second . .double() dispatch S3 methods, However, made generic return FALSE integer64. c() dispatches c.integer64() first argument integer64 recursively dispatch proper method called argument recursive=TRUE. Therefore c(list(integer64, integer64)) work now can call c.integer64(list(x, x)). generic binary operators fail dispatch user-defined S3 method two arguments two different S3 classes. example two classes bit::bit bit::bitwhich sparsely representing boolean vectors methods &.bit &.bitwhich. expression involving bit & bitwhich, none two methods dispatched. Instead standard method dispatched, neither handles bit bitwhich. Although lacks symmetry, better choice dispatch simply method class first argument case class conflict. choice allow authors extension packages providing coherent behaviour least within contributed classes. long none package author's methods dispatched, handle conflicting classes . unlist() generic , face similar problems c() vector() argument mode='integer64' work without adjustment Base R .vector() argument mode='integer64' work without adjustment Base R .vector() dispatch method .vector.integer64() mode<-() drops class 'integer64' returned .integer64(). Also remove existing class 'integer64' assigning mode 'integer'. storage.mode<-() support external data types integer64 matrix() drop 'integer64' class attribute. array()  drop 'integer64' class attribute. current R versions (1.15.1) can circumvented activating function .vector.integer64(). However, CRAN maintainer requested remove .vector.integer64(), even price breaking previously working functionality package. str() print values integer64 correctly","code":"from <- lim.integer64()[1] to <- from+99 from:to"},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"further-limitations","dir":"Reference","previous_headings":"","what":"Further limitations","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"subscripting non-existing elements subscripting NAs currently supported. subscripting currently returns 9218868437227407266 instead NA (NA value underlying double code). Following full R behaviour either destroy performance require extensive C-coding.","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"Maintainer: Michael Chirico michaelchirico4@gmail.com Authors: Jens Oehlschlägel contributors: Leonardo Silvestri [contributor] Ofek Shilon [contributor]","code":""},{"path":"https://bit64.r-lib.org/reference/bit64-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A S3 class for vectors of 64bit integers — bit64-package","text":"","code":"message(\"Using integer64 in vector\") #> Using integer64 in vector x <- integer64(8)    # create 64 bit vector x #> integer64 #> [1] 0 0 0 0 0 0 0 0 is.atomic(x)         # TRUE #> [1] TRUE is.integer64(x)      # TRUE #> [1] TRUE is.numeric(x)        # TRUE #> [1] TRUE is.integer(x)        # FALSE - debatable #> [1] FALSE is.double(x)         # FALSE - might change #> [1] FALSE x[] <- 1:2           # assigned value is recycled as usual x[1:6]               # subscripting as usual #> integer64 #> [1] 1 2 1 2 1 2 length(x) <- 13      # changing length as usual x #> integer64 #>  [1] 1 2 1 2 1 2 1 2 0 0 0 0 0 rep(x, 2)            # replicate as usual #> integer64 #>  [1] 1 2 1 2 1 2 1 2 0 0 0 0 0 1 2 1 2 1 2 1 2 0 0 0 0 0 seq(as.integer64(1), 10)     # seq.integer64 is dispatched on first given argument #> integer64 #>  [1] 1  2  3  4  5  6  7  8  9  10 seq(to=as.integer64(10), 1)  # seq.integer64 is dispatched on first given argument #> integer64 #>  [1] 1  2  3  4  5  6  7  8  9  10 seq.integer64(along.with=x)  # or call seq.integer64 directly #> integer64 #>  [1] 1  2  3  4  5  6  7  8  9  10 11 12 13 # c.integer64 is dispatched only if *first* argument is integer64 ... x <- c(x,runif(length(x), max=100)) # ... and coerces everything to integer64 - including double x #> integer64 #>  [1] 1  2  1  2  1  2  1  2  0  0  0  0  0  76 91 70 58 13 8  76 40 15 9  #> [24] 2  8  28 names(x) <- letters  # use names as usual x #> integer64 #>  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  #>  1  2  1  2  1  2  1  2  0  0  0  0  0 76 91 70 58 13  8 76 40 15  9  2  #>  y  z  #>  8 28   message(\"Using integer64 in array - note that 'matrix' currently does not work\") #> Using integer64 in array - note that 'matrix' currently does not work message(\"as.vector.integer64 removed as requested by the CRAN maintainer\") #> as.vector.integer64 removed as requested by the CRAN maintainer message(\"as consequence 'array' also does not work anymore\") #> as consequence 'array' also does not work anymore message(\"we still can create a matrix or array by assigning 'dim'\") #> we still can create a matrix or array by assigning 'dim' y <- rep(as.integer64(NA), 12) dim(y) <- c(3,4) dimnames(y) <- list(letters[1:3], LETTERS[1:4]) y[\"a\",] <- 1:2       # assigning as usual y #> integer64 #>   A    B    C    D    #> a 1    2    1    2    #> b <NA> <NA> <NA> <NA> #> c <NA> <NA> <NA> <NA> y[1:2,-4]            # subscripting as usual #> integer64 #>   A    B    C    #> a 1    2    1    #> b <NA> <NA> <NA> # cbind.integer64 dispatched on any argument and coerces everything to integer64 cbind(E=1:3, F=runif(3, 0, 100), G=c(\"-1\",\"0\",\"1\"), y) #> integer64 #>   E F  G  A    B    C    D    #> a 1 58 -1 1    2    1    2    #> b 2 71 0  <NA> <NA> <NA> <NA> #> c 3 96 1  <NA> <NA> <NA> <NA>  message(\"Using integer64 in data.frame\") #> Using integer64 in data.frame str(as.data.frame(x)) #> 'data.frame':\t26 obs. of  1 variable: #>  $ x:integer64 1 2 1 2 1 2 1 2 ...  str(as.data.frame(y)) #> 'data.frame':\t3 obs. of  4 variables: #>  $ A:integer64 1 NA NA  #>  $ B:integer64 2 NA NA  #>  $ C:integer64 1 NA NA  #>  $ D:integer64 2 NA NA  str(data.frame(y)) #> 'data.frame':\t3 obs. of  4 variables: #>  $ A:integer64 1 NA NA  #>  $ B:integer64 2 NA NA  #>  $ C:integer64 1 NA NA  #>  $ D:integer64 2 NA NA  str(data.frame(I(y))) #> 'data.frame':\t3 obs. of  1 variable: #>  $ y:integer64 1 NA NA 2 NA NA 1 NA ...  d <- data.frame(x=x, y=runif(length(x), 0, 100)) d #>    x          y #> a  1 54.0294650 #> b  2 82.8379691 #> c  1 36.9443346 #> d  2 78.9029870 #> e  1 85.1345699 #> f  2 86.8393181 #> g  1 68.9746707 #> h  2 64.7483669 #> i  0 29.8988144 #> j  0 83.8488248 #> k  0 50.9581229 #> l  0  0.6297852 #> m  0 63.9481665 #> n 76 69.5749745 #> o 91 41.0609695 #> p 70 45.4798865 #> q 58 16.2794145 #> r 13 85.1599901 #> s  8 69.5091747 #> t 76 10.9175470 #> u 40 22.8045808 #> v 15  4.8925648 #> w  9 14.1299729 #> x  2 80.4662978 #> y  8 70.5601694 #> z 28 33.7272814 d$x #> integer64 #>  [1] 1  2  1  2  1  2  1  2  0  0  0  0  0  76 91 70 58 13 8  76 40 15 9  #> [24] 2  8  28  message(\"Using integer64 with csv files\") #> Using integer64 with csv files fi64 <- tempfile() write.csv(d, file=fi64, row.names=FALSE) e <- read.csv(fi64, colClasses=c(\"integer64\", NA)) unlink(fi64) str(e) #> 'data.frame':\t26 obs. of  2 variables: #>  $ x:integer64 1 2 1 2 1 2 1 2 ...  #>  $ y: num  54 82.8 36.9 78.9 85.1 ... identical.integer64(d$x,e$x) #> [1] TRUE  message(\"Serializing and unserializing integer64\") #> Serializing and unserializing integer64 dput(d, fi64) e <- dget(fi64) identical.integer64(d$x,e$x) #> [1] TRUE e <- d[,] save(e, file=fi64) rm(e) load(file=fi64) identical.integer64(d,e) #> [1] TRUE    if (FALSE) { # \\dontrun{ message(\"== Differences between integer64 and int64 ==\") require(bit64) require(int64)  message(\"-- integer64 is atomic --\") is.atomic(integer64()) #is.atomic(int64()) str(integer64(3)) #str(int64(3))  message(\"-- The following performance numbers are measured under RWin64  --\") message(\"-- under RWin32 the advantage of integer64 over int64 is smaller --\")  message(\"-- integer64 needs 7x/5x less RAM than int64 under 64/32 bit OS (and twice the RAM of integer as it should be) --\") #as.vector(object.size(int64(1e6))/object.size(integer64(1e6))) as.vector(object.size(integer64(1e6))/object.size(integer(1e6)))  message(\"-- integer64 creates 2000x/1300x faster than int64 under 64/32 bit OS (and 3x the time of integer) --\") t32 <- system.time(integer(1e8)) t64 <- system.time(integer64(1e8)) #T64 <- system.time(int64(1e7))*10  # using 1e8 as above stalls our R on an i7 8 GB RAM Thinkpad #T64/t64 t64/t32  i32 <- sample(1e6) d64 <- as.double(i32)  message(\"-- the following timings are rather conservative since timings  of integer64 include garbage collection -- due to looped calls\") message(\"-- integer64 coerces 900x/100x faster than int64  under 64/32 bit OS (and 2x the time of coercing to integer) --\") t32 <- system.time(for(i in 1:1000)as.integer(d64)) t64 <- system.time(for(i in 1:1000)as.integer64(d64)) #T64 <- system.time(as.int64(d64))*1000 #T64/t64 t64/t32 td64 <- system.time(for(i in 1:1000)as.double(i32)) t64 <- system.time(for(i in 1:1000)as.integer64(i32)) #T64 <- system.time(for(i in 1:10)as.int64(i32))*100 #T64/t64 t64/td64  message(\"-- integer64 serializes 4x/0.8x faster than int64  under 64/32 bit OS (and less than 2x/6x the time of integer or double) --\") t32 <- system.time(for(i in 1:10)serialize(i32, NULL)) td64 <- system.time(for(i in 1:10)serialize(d64, NULL)) i64 <- as.integer64(i32); t64 <- system.time(for(i in 1:10)serialize(i64, NULL)) rm(i64); gc() #I64 <- as.int64(i32); #T64 <- system.time(for(i in 1:10)serialize(I64, NULL)) #rm(I64); gc() #T64/t64 t64/t32 t64/td64   message(\"-- integer64 adds 250x/60x faster than int64  under 64/32 bit OS (and less than 6x the time of integer or double) --\") td64 <- system.time(for(i in 1:100)d64+d64) t32 <- system.time(for(i in 1:100)i32+i32) i64 <- as.integer64(i32); t64 <- system.time(for(i in 1:100)i64+i64) rm(i64); gc() #I64 <- as.int64(i32); #T64 <- system.time(for(i in 1:10)I64+I64)*10 #rm(I64); gc() #T64/t64 t64/t32 t64/td64  message(\"-- integer64 sums 3x/0.2x faster than int64 (and at about 5x/60X the time of integer and double) --\") td64 <- system.time(for(i in 1:100)sum(d64)) t32 <- system.time(for(i in 1:100)sum(i32)) i64 <- as.integer64(i32); t64 <- system.time(for(i in 1:100)sum(i64)) rm(i64); gc() #I64 <- as.int64(i32); #T64 <- system.time(for(i in 1:100)sum(I64)) #rm(I64); gc() #T64/t64 t64/t32 t64/td64  message(\"-- integer64 diffs 5x/0.85x faster than integer and double (int64 version 1.0 does not support diff) --\") td64 <- system.time(for(i in 1:10)diff(d64, lag=2L, differences=2L)) t32 <- system.time(for(i in 1:10)diff(i32, lag=2L, differences=2L)) i64 <- as.integer64(i32); t64 <- system.time(for(i in 1:10)diff(i64, lag=2L, differences=2L)) rm(i64); gc() t64/t32 t64/td64   message(\"-- integer64 subscripts 1000x/340x faster than int64 (and at the same speed / 10x slower as integer) --\") ts32 <- system.time(for(i in 1:1000)sample(1e6, 1e3)) t32<- system.time(for(i in 1:1000)i32[sample(1e6, 1e3)]) i64 <- as.integer64(i32); t64 <- system.time(for(i in 1:1000)i64[sample(1e6, 1e3)]) rm(i64); gc() #I64 <- as.int64(i32); #T64 <- system.time(for(i in 1:100)I64[sample(1e6, 1e3)])*10 #rm(I64); gc() #(T64-ts32)/(t64-ts32) (t64-ts32)/(t32-ts32)  message(\"-- integer64 assigns 200x/90x faster than int64 (and 50x/160x slower than integer) --\") ts32 <- system.time(for(i in 1:100)sample(1e6, 1e3)) t32 <- system.time(for(i in 1:100)i32[sample(1e6, 1e3)] <- 1:1e3) i64 <- as.integer64(i32); i64 <- system.time(for(i in 1:100)i64[sample(1e6, 1e3)] <- 1:1e3) rm(i64); gc() #I64 <- as.int64(i32); #I64 <- system.time(for(i in 1:10)I64[sample(1e6, 1e3)] <- 1:1e3)*10 #rm(I64); gc() #(T64-ts32)/(t64-ts32) (t64-ts32)/(t32-ts32)   tdfi32 <- system.time(dfi32 <- data.frame(a=i32, b=i32, c=i32)) tdfsi32 <- system.time(dfi32[1e6:1,]) fi32 <- tempfile() tdfwi32 <- system.time(write.csv(dfi32, file=fi32, row.names=FALSE)) tdfri32 <- system.time(read.csv(fi32, colClasses=rep(\"integer\", 3))) unlink(fi32) rm(dfi32); gc()  i64 <- as.integer64(i32); tdfi64 <- system.time(dfi64 <- data.frame(a=i64, b=i64, c=i64)) tdfsi64 <- system.time(dfi64[1e6:1,]) fi64 <- tempfile() tdfwi64 <- system.time(write.csv(dfi64, file=fi64, row.names=FALSE)) tdfri64 <- system.time(read.csv(fi64, colClasses=rep(\"integer64\", 3))) unlink(fi64) rm(i64, dfi64); gc()  #I64 <- as.int64(i32); #tdfI64 <- system.time(dfI64<-data.frame(a=I64, b=I64, c=I64)) #tdfsI64 <- system.time(dfI64[1e6:1,]) #fI64 <- tempfile() #tdfwI64 <- system.time(write.csv(dfI64, file=fI64, row.names=FALSE)) #tdfrI64 <- system.time(read.csv(fI64, colClasses=rep(\"int64\", 3))) #unlink(fI64) #rm(I64, dfI64); gc()  message(\"-- integer64 coerces 40x/6x faster to data.frame than int64 (and factor 1/9 slower than integer) --\") #tdfI64/tdfi64 tdfi64/tdfi32 message(\"-- integer64 subscripts from data.frame 20x/2.5x faster than int64  (and 3x/13x slower than integer) --\") #tdfsI64/tdfsi64 tdfsi64/tdfsi32 message(\"-- integer64 csv writes about 2x/0.5x faster than int64 (and about 1.5x/5x slower than integer) --\") #tdfwI64/tdfwi64 tdfwi64/tdfwi32 message(\"-- integer64 csv reads about 3x/1.5 faster than int64 (and about 2x slower than integer) --\") #tdfrI64/tdfri64 tdfri64/tdfri32  rm(i32, d64); gc()   message(\"-- investigating the impact on garbage collection: --\") message(\"-- the fragmented structure of int64 messes up R's RAM --\") message(\"-- and slows down R's gargbage collection just by existing --\")  td32 <- double(21) td32[1] <- system.time(d64 <- double(1e7))[3] for (i in 2:11)td32[i] <- system.time(gc(), gcFirst=FALSE)[3] rm(d64) for (i in 12:21)td32[i] <- system.time(gc(), gcFirst=FALSE)[3]  t64 <- double(21) t64[1] <- system.time(i64 <- integer64(1e7))[3] for (i in 2:11)t64[i] <- system.time(gc(), gcFirst=FALSE)[3] rm(i64) for (i in 12:21)t64[i] <- system.time(gc(), gcFirst=FALSE)[3]  #T64 <- double(21) #T64[1] <- system.time(I64 <- int64(1e7))[3] #for (i in 2:11)T64[i] <- system.time(gc(), gcFirst=FALSE)[3] #rm(I64) #for (i in 12:21)T64[i] <- system.time(gc(), gcFirst=FALSE)[3]  #matplot(1:21, cbind(td32, t64, T64), pch=c(\"d\",\"i\",\"I\"), log=\"y\") matplot(1:21, cbind(td32, t64), pch=c(\"d\",\"i\"), log=\"y\")   } # }"},{"path":"https://bit64.r-lib.org/reference/bit64S3.html","id":null,"dir":"Reference","previous_headings":"","what":"Turning base R functions into S3 generics for bit64 — bit64S3","title":"Turning base R functions into S3 generics for bit64 — bit64S3","text":"Turn base functions S3 generic used bit64","code":""},{"path":"https://bit64.r-lib.org/reference/bit64S3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turning base R functions into S3 generics for bit64 — bit64S3","text":"","code":"from:to is.double(x) match(x, table, ...) x %in% table rank(x, ...) order(...)  # Default S3 method is.double(x)  # S3 method for class 'integer64' is.double(x)  # S3 method for class 'integer64' mtfrm(x)  # Default S3 method match(x, table, ...)  # Default S3 method x %in% table  # Default S3 method rank(x, ...)  # Default S3 method order(...)"},{"path":"https://bit64.r-lib.org/reference/bit64S3.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turning base R functions into S3 generics for bit64 — bit64S3","text":"x integer64 vector: values matched, optionally carrying cache created hashcache() table integer64 vector: values matched , optionally carrying cache created hashcache() sortordercache() ... ignored scalar denoting first element sequence scalar denoting last element sequence","code":""},{"path":"https://bit64.r-lib.org/reference/bit64S3.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turning base R functions into S3 generics for bit64 — bit64S3","text":"invisible()","code":""},{"path":"https://bit64.r-lib.org/reference/bit64S3.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Turning base R functions into S3 generics for bit64 — bit64S3","text":"following functions turned S3 generics order dispatch methods integer64(): : .double() match() %% rank() order()","code":""},{"path":"https://bit64.r-lib.org/reference/bit64S3.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Turning base R functions into S3 generics for bit64 — bit64S3","text":".double() returns FALSE integer64 : currently dispatches first argument, thus .integer64(1):9 works 1:.integer64(9) match() currently dispatches first argument expects second argument also integer64, otherwise throws error. Beware something like match(2, .integer64(0:3)) %% currently dispatches first argument expects second argument also integer64, otherwise throws error. Beware something like 2 %% .integer64(0:3) order() currently orders single argument, trying one raises error","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/bit64S3.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turning base R functions into S3 generics for bit64 — bit64S3","text":"","code":"is.double(as.integer64(1)) #> [1] FALSE     as.integer64(1):9 #> integer64 #> [1] 1 2 3 4 5 6 7 8 9  match(as.integer64(2), as.integer64(0:3)) #> [1] 3  as.integer64(2) %in% as.integer64(0:3) #> [1] TRUE   unique(as.integer64(c(1,1,2))) #> integer64 #> [1] 1 2  rank(as.integer64(c(1,1,2))) #> [1] 1.5 1.5 3.0    order(as.integer64(c(1,NA,2))) #> [1] 1 3 2"},{"path":"https://bit64.r-lib.org/reference/c.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Concatenating integer64 vectors — c.integer64","title":"Concatenating integer64 vectors — c.integer64","text":"ususal functions 'c', 'cbind' 'rbind'","code":""},{"path":"https://bit64.r-lib.org/reference/c.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Concatenating integer64 vectors — c.integer64","text":"","code":"# S3 method for class 'integer64' c(..., recursive = FALSE)  # S3 method for class 'integer64' cbind(...)  # S3 method for class 'integer64' rbind(...)"},{"path":"https://bit64.r-lib.org/reference/c.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Concatenating integer64 vectors — c.integer64","text":"... two arguments coerced 'integer64' passed NextMethod() recursive logical. recursive = TRUE, function recursively descends lists (pairlists) combining elements vector.","code":""},{"path":"https://bit64.r-lib.org/reference/c.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Concatenating integer64 vectors — c.integer64","text":"c() returns integer64 vector total length input cbind() rbind() return integer64 matrix","code":""},{"path":"https://bit64.r-lib.org/reference/c.integer64.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Concatenating integer64 vectors — c.integer64","text":"R currently dispatches generic 'c' method 'c.integer64' first argument 'integer64'","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/c.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Concatenating integer64 vectors — c.integer64","text":"","code":"c(as.integer64(1), 2:6) #> integer64 #> [1] 1 2 3 4 5 6   cbind(1:6, as.integer(1:6)) #>      [,1] [,2] #> [1,]    1    1 #> [2,]    2    2 #> [3,]    3    3 #> [4,]    4    4 #> [5,]    5    5 #> [6,]    6    6   rbind(1:6, as.integer(1:6)) #>      [,1] [,2] [,3] [,4] [,5] [,6] #> [1,]    1    2    3    4    5    6 #> [2,]    1    2    3    4    5    6"},{"path":"https://bit64.r-lib.org/reference/cache.html","id":null,"dir":"Reference","previous_headings":"","what":"Atomic Caching — cache","title":"Atomic Caching — cache","text":"Functions caching results attached atomic objects","code":""},{"path":"https://bit64.r-lib.org/reference/cache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Atomic Caching — cache","text":"","code":"newcache(x)  jamcache(x)  cache(x)  setcache(x, which, value)  getcache(x, which)  remcache(x)  # S3 method for class 'cache' print(x, all.names = FALSE, pattern, ...)"},{"path":"https://bit64.r-lib.org/reference/cache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Atomic Caching — cache","text":"x integer64 vector (cache object case print.cache) character naming object retrieved cache stored cache value object stored cache .names, pattern passed ls() listing cache content ... ignored","code":""},{"path":"https://bit64.r-lib.org/reference/cache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Atomic Caching — cache","text":"See details","code":""},{"path":"https://bit64.r-lib.org/reference/cache.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Atomic Caching — cache","text":"cache environment attached atomic object attribute name 'cache'. contains least reference atomic object carries cache. used accessing cache detect whether object carrying cache modified meanwhile.","code":""},{"path":"https://bit64.r-lib.org/reference/cache.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Atomic Caching — cache","text":"newcache(): creates new cache referencing  x jamcache(): forces x cache cache(): returns cache attached x found outdated setcache(): assigns value cache x getcache(): gets cache value '' x remcache(): removes cache x","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/cache.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Atomic Caching — cache","text":"","code":"x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))   y <- x   still.identical(x,y) #> [1] TRUE   y[1] <- NA   still.identical(x,y) #> [1] FALSE   mycache <- newcache(x)   ls(mycache) #> [1] \"x\"   mycache #> cache_integer64: x   rm(mycache)   jamcache(x) #> cache_integer64: x   cache(x) #> cache_integer64: x   x[1] <- NA   cache(x) #> Warning: removed outdated cache #> NULL   getcache(x, \"abc\") #> NULL   setcache(x, \"abc\", 1) #> cache_integer64: abc - x   getcache(x, \"abc\") #> [1] 1   remcache(x)   cache(x) #> NULL"},{"path":"https://bit64.r-lib.org/reference/cumsum.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Cumulative Sums, Products, Extremes and lagged differences — cumsum.integer64","title":"Cumulative Sums, Products, Extremes and lagged differences — cumsum.integer64","text":"Cumulative Sums, Products, Extremes lagged differences","code":""},{"path":"https://bit64.r-lib.org/reference/cumsum.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cumulative Sums, Products, Extremes and lagged differences — cumsum.integer64","text":"","code":"# S3 method for class 'integer64' diff(x, lag = 1L, differences = 1L, ...)  # S3 method for class 'integer64' cummin(x)  # S3 method for class 'integer64' cummax(x)  # S3 method for class 'integer64' cumsum(x)  # S3 method for class 'integer64' cumprod(x)"},{"path":"https://bit64.r-lib.org/reference/cumsum.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cumulative Sums, Products, Extremes and lagged differences — cumsum.integer64","text":"x atomic vector class 'integer64' lag see diff() differences see diff() ... ignored","code":""},{"path":"https://bit64.r-lib.org/reference/cumsum.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cumulative Sums, Products, Extremes and lagged differences — cumsum.integer64","text":"cummin(), cummax() , cumsum() cumprod() return integer64 vector length input diff() returns integer64 vector shorter lag*differences elements","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/cumsum.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cumulative Sums, Products, Extremes and lagged differences — cumsum.integer64","text":"","code":"cumsum(rep(as.integer64(1), 12)) #> integer64 #>  [1] 1  2  3  4  5  6  7  8  9  10 11 12   diff(as.integer64(c(0,1:12))) #> integer64 #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1   cumsum(as.integer64(c(0, 1:12))) #> integer64 #>  [1] 0  1  3  6  10 15 21 28 36 45 55 66 78   diff(cumsum(as.integer64(c(0,0,1:12))), differences=2) #> integer64 #>  [1] 1 1 1 1 1 1 1 1 1 1 1 1"},{"path":"https://bit64.r-lib.org/reference/duplicated.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine Duplicate Elements of integer64 — duplicated.integer64","title":"Determine Duplicate Elements of integer64 — duplicated.integer64","text":"duplicated() determines elements vector data frame duplicates elements smaller subscripts, returns logical vector indicating elements (rows) duplicates.","code":""},{"path":"https://bit64.r-lib.org/reference/duplicated.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine Duplicate Elements of integer64 — duplicated.integer64","text":"","code":"# S3 method for class 'integer64' duplicated(x, incomparables = FALSE, nunique = NULL, method = NULL, ...)"},{"path":"https://bit64.r-lib.org/reference/duplicated.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine Duplicate Elements of integer64 — duplicated.integer64","text":"x vector data frame array NULL. incomparables ignored nunique NULL number unique values (including NA). Providing nunique can speed-matching x cache. Note wrong nunique can cause undefined behaviour crash. method NULL automatic method selection suitable low-level method, see details ... ignored","code":""},{"path":"https://bit64.r-lib.org/reference/duplicated.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine Duplicate Elements of integer64 — duplicated.integer64","text":"duplicated(): logical vector length x.","code":""},{"path":"https://bit64.r-lib.org/reference/duplicated.integer64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Determine Duplicate Elements of integer64 — duplicated.integer64","text":"function automatically chooses several low-level functions considering size x availability cache. Suitable methods hashdup (hashing) sortorderdup (fast ordering) orderdup (memory saving ordering).","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/duplicated.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine Duplicate Elements of integer64 — duplicated.integer64","text":"","code":"x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE)) duplicated(x) #>  [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE #> [12]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE #> [23]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  stopifnot(identical(duplicated(x),  duplicated(as.integer(x))))"},{"path":"https://bit64.r-lib.org/reference/extract.replace.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract or Replace Parts of an integer64 vector — extract.replace.integer64","title":"Extract or Replace Parts of an integer64 vector — extract.replace.integer64","text":"Methods extract replace parts integer64 vector.","code":""},{"path":"https://bit64.r-lib.org/reference/extract.replace.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract or Replace Parts of an integer64 vector — extract.replace.integer64","text":"","code":"# S3 method for class 'integer64' x[i, ...]  # S3 method for class 'integer64' x[...] <- value  # S3 method for class 'integer64' x[[...]]  # S3 method for class 'integer64' x[[...]] <- value"},{"path":"https://bit64.r-lib.org/reference/extract.replace.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract or Replace Parts of an integer64 vector — extract.replace.integer64","text":"x atomic vector indices specifying elements extract ... arguments NextMethod() value atomic vector values assigned","code":""},{"path":"https://bit64.r-lib.org/reference/extract.replace.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract or Replace Parts of an integer64 vector — extract.replace.integer64","text":"vector scalar class 'integer64'","code":""},{"path":"https://bit64.r-lib.org/reference/extract.replace.integer64.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extract or Replace Parts of an integer64 vector — extract.replace.integer64","text":"subscript non-existing elements use NAs subscripts. current implementation returns 9218868437227407266 instead NA.","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/extract.replace.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract or Replace Parts of an integer64 vector — extract.replace.integer64","text":"","code":"as.integer64(1:12)[1:3] #> integer64 #> [1] 1 2 3   x <- as.integer64(1:12)   dim(x) <- c(3,4)   x #> integer64 #>      [,1] [,2] [,3] [,4] #> [1,] 1    4    7    10   #> [2,] 2    5    8    11   #> [3,] 3    6    9    12     x[] #> integer64 #>      [,1] [,2] [,3] [,4] #> [1,] 1    4    7    10   #> [2,] 2    5    8    11   #> [3,] 3    6    9    12     x[,2:3] #> integer64 #>      [,1] [,2] #> [1,] 4    7    #> [2,] 5    8    #> [3,] 6    9"},{"path":"https://bit64.r-lib.org/reference/format.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Unary operators and functions for integer64 vectors — format.integer64","title":"Unary operators and functions for integer64 vectors — format.integer64","text":"Unary operators functions integer64 vectors.","code":""},{"path":"https://bit64.r-lib.org/reference/format.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unary operators and functions for integer64 vectors — format.integer64","text":"","code":"# S3 method for class 'integer64' format(x, justify = \"right\", ...)  # S3 method for class 'integer64' sign(x)  # S3 method for class 'integer64' abs(x)  # S3 method for class 'integer64' sqrt(x)  # S3 method for class 'integer64' log(x, base = NULL)  # S3 method for class 'integer64' log10(x)  # S3 method for class 'integer64' log2(x)  # S3 method for class 'integer64' trunc(x, ...)  # S3 method for class 'integer64' floor(x)  # S3 method for class 'integer64' ceiling(x)  # S3 method for class 'integer64' signif(x, digits = 6L)  # S3 method for class 'integer64' scale(x, center = TRUE, scale = TRUE)  # S3 method for class 'integer64' round(x, digits = 0L)  # S3 method for class 'integer64' is.na(x)  # S3 method for class 'integer64' is.finite(x)  # S3 method for class 'integer64' is.infinite(x)  # S3 method for class 'integer64' is.nan(x)  # S3 method for class 'integer64' !x"},{"path":"https://bit64.r-lib.org/reference/format.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unary operators and functions for integer64 vectors — format.integer64","text":"x atomic vector class 'integer64' justify right-justified (default), left-justified, centred left alone. ... arguments NextMethod() base atomic scalar (save 50% log-calls allowing vector base) digits integer indicating number decimal places (round) significant digits (signif) used. Negative values allowed (see round()) center see scale() scale see scale()","code":""},{"path":"https://bit64.r-lib.org/reference/format.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unary operators and functions for integer64 vectors — format.integer64","text":"format() returns character vector .na() ! return logical vector sqrt(), log(), log2() log10() return double vector sign(), abs(), floor(), ceiling(), trunc() round() return vector class 'integer64' signif() implemented","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/format.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unary operators and functions for integer64 vectors — format.integer64","text":"","code":"sqrt(as.integer64(1:12)) #>  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 #>  [8] 2.828427 3.000000 3.162278 3.316625 3.464102"},{"path":"https://bit64.r-lib.org/reference/hashcache.html","id":null,"dir":"Reference","previous_headings":"","what":"Big caching of hashing, sorting, ordering — hashcache","title":"Big caching of hashing, sorting, ordering — hashcache","text":"Functions create cache accelerates many operations","code":""},{"path":"https://bit64.r-lib.org/reference/hashcache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Big caching of hashing, sorting, ordering — hashcache","text":"","code":"hashcache(x, nunique = NULL, ...)  sortcache(x, has.na = NULL)  sortordercache(x, has.na = NULL, stable = NULL)  ordercache(x, has.na = NULL, stable = NULL, optimize = \"time\")"},{"path":"https://bit64.r-lib.org/reference/hashcache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Big caching of hashing, sorting, ordering — hashcache","text":"x atomic vector (note currently integer64 supported) nunique giving correct number unique elements can help reducing size hashmap ... passed hashmap() .na boolean scalar defining whether input vector might contain NAs. know NAs, may speed-. Note risk crash unexpected NAs .na=FALSE. stable boolean scalar defining whether stable sorting needed. Allowing non-stable may speed-. optimize default ramsort optimizes 'time' requires RAM, set 'memory' minimize RAM requirements sacrifice speed.","code":""},{"path":"https://bit64.r-lib.org/reference/hashcache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Big caching of hashing, sorting, ordering — hashcache","text":"x cache() contains result expensive operations, possible together small derived information (nunique.integer64()) previously cached results.","code":""},{"path":"https://bit64.r-lib.org/reference/hashcache.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Big caching of hashing, sorting, ordering — hashcache","text":"result relative expensive operations hashmap(), bit::ramsort(), bit::ramsortorder(), bit::ramorder() can stored cache order avoid multiple excutions. Unless specific situations, recommended method hashsortorder .","code":""},{"path":"https://bit64.r-lib.org/reference/hashcache.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Big caching of hashing, sorting, ordering — hashcache","text":"Note consider storing big results sorting /ordering relevant side-effect, therefore storing cache require conscious decision user.","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/hashcache.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Big caching of hashing, sorting, ordering — hashcache","text":"","code":"x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))   sortordercache(x)"},{"path":"https://bit64.r-lib.org/reference/hashmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Hashing for 64bit integers — hashmap","title":"Hashing for 64bit integers — hashmap","text":"explicit implementation hash functionality underlies matching functions R. Explicit means can create, store use hash functionality directly. One advantage can re-use hashmaps, avoid re-building hashmaps .","code":""},{"path":"https://bit64.r-lib.org/reference/hashmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hashing for 64bit integers — hashmap","text":"","code":"hashfun(x, ...)  # S3 method for class 'integer64' hashfun(x, minfac = 1.41, hashbits = NULL, ...)  hashmap(x, ...)  # S3 method for class 'integer64' hashmap(x, nunique = NULL, minfac = 1.41, hashbits = NULL, cache = NULL, ...)  hashpos(cache, ...)  # S3 method for class 'cache_integer64' hashpos(cache, x, nomatch = NA_integer_, ...)  hashrev(cache, ...)  # S3 method for class 'cache_integer64' hashrev(cache, x, nomatch = NA_integer_, ...)  hashfin(cache, ...)  # S3 method for class 'cache_integer64' hashfin(cache, x, ...)  hashrin(cache, ...)  # S3 method for class 'cache_integer64' hashrin(cache, x, ...)  hashdup(cache, ...)  # S3 method for class 'cache_integer64' hashdup(cache, ...)  hashuni(cache, ...)  # S3 method for class 'cache_integer64' hashuni(cache, keep.order = FALSE, ...)  hashupo(cache, ...)  # S3 method for class 'cache_integer64' hashupo(cache, keep.order = FALSE, ...)  hashtab(cache, ...)  # S3 method for class 'cache_integer64' hashtab(cache, ...)  hashmaptab(x, ...)  # S3 method for class 'integer64' hashmaptab(x, nunique = NULL, minfac = 1.5, hashbits = NULL, ...)  hashmapuni(x, ...)  # S3 method for class 'integer64' hashmapuni(x, nunique = NULL, minfac = 1.5, hashbits = NULL, ...)  hashmapupo(x, ...)  # S3 method for class 'integer64' hashmapupo(x, nunique = NULL, minfac = 1.5, hashbits = NULL, ...)"},{"path":"https://bit64.r-lib.org/reference/hashmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hashing for 64bit integers — hashmap","text":"x integer64 vector ... arguments, passed generics, ignored methods minfac minimum factor hasmap elements compared data x, ignored hashbits given directly hashbits length hashmap 2^hashbits nunique giving correct number unique elements can help reducing size hashmap cache optional cache() object put hashmap (default new cache created nomatch value returned element found hashmap keep.order determines order results speed: FALSE (default) faster returns (pseudo)random order hash function, TRUE returns order first appearance original data, requires extra work","code":""},{"path":"https://bit64.r-lib.org/reference/hashmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hashing for 64bit integers — hashmap","text":"See Details","code":""},{"path":[]},{"path":[]},{"path":"https://bit64.r-lib.org/reference/hashmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hashing for 64bit integers — hashmap","text":"","code":"x <- as.integer64(sample(c(NA, 0:9))) y <- as.integer64(sample(c(NA, 1:9), 10, TRUE)) hashfun(y) #>  [1] 11  8  8  3  1  3  9 15  7  8 hx <- hashmap(x) hy <- hashmap(y) ls(hy) #> [1] \"hashbits\" \"hashmap\"  \"nhash\"    \"nunique\"  \"x\"        hashpos(hy, x) #>  [1]  1  7  8  9 NA  2 NA NA  4  5 NA hashrev(hx, y) #>  [1]  1  7  8  9 NA  2 NA NA  4  5 NA hashfin(hy, x) #>  [1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE hashrin(hx, y) #>  [1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE hashdup(hy) #>  [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE hashuni(hy) #> integer64 #> [1] 5    2    4    <NA> 1    6    8    hashuni(hy, keep.order=TRUE) #> integer64 #> [1] 6    <NA> 2    5    1    8    4    hashmapuni(y) #> integer64 #> [1] 6    <NA> 2    5    1    8    4    hashupo(hy) #> [1] 5 4 9 2 7 1 8 hashupo(hy, keep.order=TRUE) #> [1] 1 2 4 5 7 8 9 hashmapupo(y) #> [1] 1 2 4 5 7 8 9 hashtab(hy) #> $values #> integer64 #> [1] 5    2    4    <NA> 1    6    8    #>  #> $counts #> [1] 1 2 1 3 1 1 1 #>  hashmaptab(y) #> $values #> integer64 #> [1] 5    2    4    <NA> 1    6    8    #>  #> $counts #> [1] 1 2 1 3 1 1 1 #>   stopifnot(identical(match(as.integer(x),as.integer(y)),hashpos(hy, x))) stopifnot(identical(match(as.integer(x),as.integer(y)),hashrev(hx, y))) stopifnot(identical(as.integer(x) %in% as.integer(y), hashfin(hy, x))) stopifnot(identical(as.integer(x) %in% as.integer(y), hashrin(hx, y))) stopifnot(identical(duplicated(as.integer(y)), hashdup(hy))) stopifnot(identical(as.integer64(unique(as.integer(y))), hashuni(hy, keep.order=TRUE))) stopifnot(identical(sort(hashuni(hy, keep.order=FALSE)), sort(hashuni(hy, keep.order=TRUE)))) stopifnot(identical(y[hashupo(hy, keep.order=FALSE)], hashuni(hy, keep.order=FALSE))) stopifnot(identical(y[hashupo(hy, keep.order=TRUE)], hashuni(hy, keep.order=TRUE))) stopifnot(identical(hashpos(hy, hashuni(hy, keep.order=TRUE)), hashupo(hy, keep.order=TRUE))) stopifnot(identical(hashpos(hy, hashuni(hy, keep.order=FALSE)), hashupo(hy, keep.order=FALSE))) stopifnot(identical(hashuni(hy, keep.order=FALSE), hashtab(hy)$values)) stopifnot(identical(as.vector(table(as.integer(y), useNA=\"ifany\")) , hashtab(hy)$counts[order.integer64(hashtab(hy)$values)])) stopifnot(identical(hashuni(hy, keep.order=TRUE), hashmapuni(y))) stopifnot(identical(hashupo(hy, keep.order=TRUE), hashmapupo(y))) stopifnot(identical(hashtab(hy), hashmaptab(y)))      if (FALSE) { # \\dontrun{     message(\"explore speed given size of the hasmap in 2^hashbits and size of the data\")     message(\"more hashbits means more random access and less collisions\")     message(\"i.e. more data means less random access and more collisions\")     bits <- 24     b <- seq(-1, 0, 0.1)     tim <- matrix(NA, length(b), 2, dimnames=list(b, c(\"bits\",\"bits+1\")))     for (i in 1:length(b)){       n <- as.integer(2^(bits+b[i]))       x <- as.integer64(sample(n))       tim[i,1] <- repeat.time(hashmap(x, hashbits=bits))[3]       tim[i,2] <- repeat.time(hashmap(x, hashbits=bits+1))[3]       print(tim)       matplot(b, tim)     }     message(\"we conclude that n*sqrt(2) is enough to avoid collisions\")     } # }"},{"path":"https://bit64.r-lib.org/reference/identical.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Identity function for class 'integer64' — identical.integer64","title":"Identity function for class 'integer64' — identical.integer64","text":"discover deviation objects containing integer64 vectors.","code":""},{"path":"https://bit64.r-lib.org/reference/identical.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identity function for class 'integer64' — identical.integer64","text":"","code":"identical.integer64(   x,   y,   num.eq = FALSE,   single.NA = FALSE,   attrib.as.set = TRUE,   ignore.bytecode = TRUE,   ignore.environment = FALSE,   ignore.srcref = TRUE,   ... )"},{"path":"https://bit64.r-lib.org/reference/identical.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identity function for class 'integer64' — identical.integer64","text":"x, y Atomic vector class 'integer64' num.eq, single.NA, attrib..set, ignore.bytecode, ignore.environment, ignore.srcref See identical(). ... Passed identical(). extptr..ref= available R 4.4.1, versions R >= 4.2.0.","code":""},{"path":"https://bit64.r-lib.org/reference/identical.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identity function for class 'integer64' — identical.integer64","text":"single logical value, TRUE FALSE, never NA never anything single value.","code":""},{"path":"https://bit64.r-lib.org/reference/identical.integer64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Identity function for class 'integer64' — identical.integer64","text":"simply wrapper identical() default arguments num.eq = FALSE, single.NA = FALSE.","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/identical.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identity function for class 'integer64' — identical.integer64","text":"","code":"i64 <- as.double(NA); class(i64) <- \"integer64\"   identical(i64-1, i64+1) #> [1] TRUE   identical.integer64(i64-1, i64+1) #> [1] FALSE"},{"path":"https://bit64.r-lib.org/reference/is.sorted.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Small cache access methods — is.sorted.integer64","title":"Small cache access methods — is.sorted.integer64","text":"methods packaged methods packages bit64 ff.","code":""},{"path":"https://bit64.r-lib.org/reference/is.sorted.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Small cache access methods — is.sorted.integer64","text":"","code":"# S3 method for class 'integer64' na.count(x, ...)  # S3 method for class 'integer64' nvalid(x, ...)  # S3 method for class 'integer64' is.sorted(x, ...)  # S3 method for class 'integer64' nunique(x, ...)  # S3 method for class 'integer64' nties(x, ...)"},{"path":"https://bit64.r-lib.org/reference/is.sorted.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Small cache access methods — is.sorted.integer64","text":"x object ... ignored","code":""},{"path":"https://bit64.r-lib.org/reference/is.sorted.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Small cache access methods — is.sorted.integer64","text":".sorted returns logical scalar, methods return integer scalar.","code":""},{"path":"https://bit64.r-lib.org/reference/is.sorted.integer64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Small cache access methods — is.sorted.integer64","text":"functions benefit sortcache(), ordercache() sortordercache(). na.count(), nvalid() nunique() also benefit hashcache().","code":""},{"path":"https://bit64.r-lib.org/reference/is.sorted.integer64.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Small cache access methods — is.sorted.integer64","text":"na.count(integer64): returns number NAs nvalid(integer64): returns number valid data points, usually length() minus na.count. .sorted(integer64): checks sortedness x (NAs sorted first) nunique(integer64): returns number unique values nties(integer64): returns number tied values.","code":""},{"path":"https://bit64.r-lib.org/reference/is.sorted.integer64.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Small cache access methods — is.sorted.integer64","text":"cache() exists desired value cached, functions store result cache. consider relevant side-effect, since small cache results relevant memory footprint.","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/is.sorted.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Small cache access methods — is.sorted.integer64","text":"","code":"x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))  length(x) #> [1] 32  na.count(x) #> [1] 16  nvalid(x) #> [1] 16  nunique(x) #> [1] 9  nties(x) #> [1] 30  table.integer64(x) #> x #> <NA>    1    2    3    4    5    7    8    9  #>   16    4    2    1    1    2    2    2    2   x #> integer64 #>  [1] <NA> 5    <NA> <NA> <NA> <NA> 1    <NA> <NA> <NA> 2    3    1    9    #> [15] 2    8    8    <NA> <NA> 7    1    7    <NA> 5    4    <NA> 1    <NA> #> [29] <NA> <NA> <NA> 9"},{"path":"https://bit64.r-lib.org/reference/keypos.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Positions in redundant dimension table — keypos","title":"Extract Positions in redundant dimension table — keypos","text":"keypos returns positions (fact table) elements participate sorted unique subset (dimension table)","code":""},{"path":"https://bit64.r-lib.org/reference/keypos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Positions in redundant dimension table — keypos","text":"","code":"keypos(x, ...)  # S3 method for class 'integer64' keypos(x, method = NULL, ...)"},{"path":"https://bit64.r-lib.org/reference/keypos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Positions in redundant dimension table — keypos","text":"x vector data frame array NULL. ... ignored method NULL automatic method selection suitable low-level method, see details","code":""},{"path":"https://bit64.r-lib.org/reference/keypos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Positions in redundant dimension table — keypos","text":"integer vector length x containing positions relative sort(unique(x), na.last=FALSE)","code":""},{"path":"https://bit64.r-lib.org/reference/keypos.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Positions in redundant dimension table — keypos","text":"NAs sorted first dimension table, see ramorder.integer64(). function automatically chooses several low-level functions considering size x availability cache. Suitable methods sortorderkey (fast ordering) orderkey (memory saving ordering).","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/keypos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Positions in redundant dimension table — keypos","text":"","code":"x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE)) keypos(x) #>  [1] 3 5 1 1 1 2 6 1 1 3 1 1 1 3 1 1 1 6 1 1 1 6 5 5 1 1 1 1 4 1 3 2  stopifnot(identical(keypos(x),  match.integer64(x, sort(unique(x), na.last=FALSE))))"},{"path":"https://bit64.r-lib.org/reference/match.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"64-bit integer matching — match.integer64","title":"64-bit integer matching — match.integer64","text":"match returns vector positions (first) matches first argument second. %% intuitive interface binary operator, returns logical vector indicating match left operand.","code":""},{"path":"https://bit64.r-lib.org/reference/match.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"64-bit integer matching — match.integer64","text":"","code":"# S3 method for class 'integer64' match(x, table, nomatch = NA_integer_, nunique = NULL, method = NULL, ...)  # S3 method for class 'integer64' `%in%`(x, table, ...)"},{"path":"https://bit64.r-lib.org/reference/match.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"64-bit integer matching — match.integer64","text":"x integer64 vector: values matched, optionally carrying cache created hashcache() table integer64 vector: values matched , optionally carrying cache created hashcache() sortordercache() nomatch value returned case match found. Note coerced integer. nunique NULL number unique values table (including NA). Providing nunique can speed-matching table cache. Note wrong nunique can cause undefined behaviour crash. method NULL automatic method selection suitable low-level method, see details ... ignored","code":""},{"path":"https://bit64.r-lib.org/reference/match.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"64-bit integer matching — match.integer64","text":"vector length x. match: integer vector giving position table first match match, otherwise nomatch. x[] found equal table[j] value returned -th position return value j, smallest possible j.  match found, value nomatch. %%: logical vector, indicating match located element x: thus values TRUE FALSE never NA.","code":""},{"path":"https://bit64.r-lib.org/reference/match.integer64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"64-bit integer matching — match.integer64","text":"functions automatically choose several low-level functions considering size x table availability caches. Suitable methods %%.integer64 hashpos (hash table lookup) hashrev (reverse lookup) sortorderpos (fast ordering) orderpos (memory saving ordering). Suitable methods match.integer64 hashfin (hash table lookup) hashrin (reverse lookup) sortfin (fast sorting) orderfin (memory saving ordering).","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/match.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"64-bit integer matching — match.integer64","text":"","code":"x <- as.integer64(c(NA, 0:9), 32) table <- as.integer64(c(1:9, NA)) match.integer64(x, table) #>  [1] 10 NA  1  2  3  4  5  6  7  8  9 \"%in%.integer64\"(x, table) #>  [1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  x <- as.integer64(sample(c(rep(NA, 9), 0:9), 32, TRUE)) table <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE)) stopifnot(identical(match.integer64(x, table), match(as.integer(x), as.integer(table)))) stopifnot(identical(\"%in%.integer64\"(x, table), as.integer(x) %in% as.integer(table)))  if (FALSE) { # \\dontrun{     message(\"check when reverse hash-lookup beats standard hash-lookup\")     e <- 4:24     timx <- timy <- matrix(NA, length(e), length(e), dimnames=list(e,e))     for (iy in seq_along(e))     for (ix in 1:iy){         nx <- 2^e[ix]         ny <- 2^e[iy]         x <- as.integer64(sample(ny, nx, FALSE))         y <- as.integer64(sample(ny, ny, FALSE))         #hashfun(x, bits=as.integer(5))         timx[ix,iy] <- repeat.time({         hx <- hashmap(x)         py <- hashrev(hx, y)         })[3]         timy[ix,iy] <- repeat.time({         hy <- hashmap(y)         px <- hashpos(hy, x)         })[3]         #identical(px, py)         print(round(timx[1:iy,1:iy]/timy[1:iy,1:iy], 2), na.print=\"\")     }      message(\"explore best low-level method given size of x and table\")     B1 <- 1:27     B2 <- 1:27     tim <- array(NA, dim=c(length(B1), length(B2), 5)  , dimnames=list(B1, B2, c(\"hashpos\",\"hashrev\",\"sortpos1\",\"sortpos2\",\"sortpos3\")))     for (i1 in B1)     for (i2 in B2)     {       b1 <- B1[i1]       b2 <- B1[i2]       n1 <- 2^b1       n2 <- 2^b2       x1 <- as.integer64(c(sample(n2, n1-1, TRUE), NA))       x2 <- as.integer64(c(sample(n2, n2-1, TRUE), NA))       tim[i1,i2,1] <- repeat.time({h <- hashmap(x2);hashpos(h, x1);rm(h)})[3]       tim[i1,i2,2] <- repeat.time({h <- hashmap(x1);hashrev(h, x2);rm(h)})[3]       s <- clone(x2); o <- seq_along(s); ramsortorder(s, o)       tim[i1,i2,3] <- repeat.time(sortorderpos(s, o, x1, method=1))[3]       tim[i1,i2,4] <- repeat.time(sortorderpos(s, o, x1, method=2))[3]       tim[i1,i2,5] <- repeat.time(sortorderpos(s, o, x1, method=3))[3]       rm(s,o)       print(apply(tim, 1:2, function(ti)if(any(is.na(ti)))NA else which.min(ti)))     } } # }"},{"path":"https://bit64.r-lib.org/reference/matrix64.html","id":null,"dir":"Reference","previous_headings":"","what":"Working with integer64 arrays and matrices — matrix64","title":"Working with integer64 arrays and matrices — matrix64","text":"functions methods facilitate working integer64 objects stored matrices. ever, primary motivation tailor-made functions R's methods often receive input bit64 treat vectors doubles, leading unexpected /incorrect results.","code":""},{"path":"https://bit64.r-lib.org/reference/matrix64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Working with integer64 arrays and matrices — matrix64","text":"","code":"colSums(x, na.rm = FALSE, dims = 1L)  # Default S3 method colSums(x, na.rm = FALSE, dims = 1L)  # S3 method for class 'integer64' colSums(x, na.rm = FALSE, dims = 1L)  rowSums(x, na.rm = FALSE, dims = 1L)  # Default S3 method rowSums(x, na.rm = FALSE, dims = 1L)  # S3 method for class 'integer64' rowSums(x, na.rm = FALSE, dims = 1L)  # S3 method for class 'integer64' aperm(a, perm, ...)"},{"path":"https://bit64.r-lib.org/reference/matrix64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Working with integer64 arrays and matrices — matrix64","text":"x array integer64 numbers. na.rm, dims interpretation colSums(). , perm Passed aperm(). ... Passed subsequent methods.","code":""},{"path":"https://bit64.r-lib.org/reference/matrix64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Working with integer64 arrays and matrices — matrix64","text":"now, colSums() rowSums() methods implemented wrappers around equivalent apply() approaches, re-using default routine (applying integer64 result) work objects missing elements. Ideally eventually get dedicated C routine mimicking colSums() integers; feature requests PRs welcome. aperm() required apply() work, general, otherwise FUN gets applied class-stripped version input.","code":""},{"path":"https://bit64.r-lib.org/reference/matrix64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Working with integer64 arrays and matrices — matrix64","text":"","code":"A = as.integer64(1:6) dim(A) = 3:2  colSums(A) #> integer64 #> [1] 6  15 rowSums(A) #> integer64 #> [1] 5 7 9 aperm(A, 2:1) #> integer64 #>      [,1] [,2] [,3] #> [1,] 1    2    3    #> [2,] 4    5    6    #> attr(,\"class\") #> [1] matrix array"},{"path":"https://bit64.r-lib.org/reference/optimizer64.data.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit — optimizer64.data","title":"Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit — optimizer64.data","text":"results calling optimizer64()","code":""},{"path":"https://bit64.r-lib.org/reference/optimizer64.data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit — optimizer64.data","text":"","code":"data(optimizer64.data)"},{"path":"https://bit64.r-lib.org/reference/optimizer64.data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit — optimizer64.data","text":"format :","code":"List of 16  $ : num [1:9, 1:3] 0 0 1.63 0.00114 2.44 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:9] \"match\" \"match.64\" \"hashpos\" \"hashrev\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:10, 1:3] 0 0 0 1.62 0.00114 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:10] \"%in%\" \"match.64\" \"%in%.64\" \"hashfin\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:10, 1:3] 0 0 0.00105 0.00313 0.00313 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:10] \"duplicated\" \"duplicated.64\" \"hashdup\" \"sortorderdup1\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:15, 1:3] 0 0 0 0.00104 0.00104 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:15] \"unique\" \"unique.64\" \"hashmapuni\" \"hashuni\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:14, 1:3] 0 0 0 0.000992 0.000992 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:14] \"unique\" \"unipos.64\" \"hashmapupo\" \"hashupo\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:13, 1:3] 0 0 0 0 0.000419 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:13] \"tabulate\" \"table\" \"table.64\" \"hashmaptab\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:7, 1:3] 0 0 0 0.00236 0.00714 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:7] \"rank\" \"rank.keep\" \"rank.64\" \"sortorderrnk\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:6, 1:3] 0 0 0.00189 0.00714 0 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:6] \"quantile\" \"quantile.64\" \"sortqtl\" \"orderqtl\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:9, 1:3] 0 0 0.00105 1.17 0 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:9] \"match\" \"match.64\" \"hashpos\" \"hashrev\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:10, 1:3] 0 0 0 0.00104 1.18 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:10] \"%in%\" \"match.64\" \"%in%.64\" \"hashfin\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:10, 1:3] 0 0 1.64 2.48 2.48 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:10] \"duplicated\" \"duplicated.64\" \"hashdup\" \"sortorderdup1\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:15, 1:3] 0 0 0 1.64 1.64 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:15] \"unique\" \"unique.64\" \"hashmapuni\" \"hashuni\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:14, 1:3] 0 0 0 1.62 1.62 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:14] \"unique\" \"unipos.64\" \"hashmapupo\" \"hashupo\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:13, 1:3] 0 0 0 0 0.32 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:13] \"tabulate\" \"table\" \"table.64\" \"hashmaptab\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:7, 1:3] 0 0 0 2.96 10.69 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:7] \"rank\" \"rank.keep\" \"rank.64\" \"sortorderrnk\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  $ : num [1:6, 1:3] 0 0 1.62 10.61 0 ...   ..- attr(*, \"dimnames\")=List of 2   .. ..$ : chr [1:6] \"quantile\" \"quantile.64\" \"sortqtl\" \"orderqtl\" ...   .. ..$ : chr [1:3] \"prep\" \"both\" \"use\"  - attr(*, \"dim\")= int [1:2] 8 2  - attr(*, \"dimnames\")=List of 2   ..$ : chr [1:8] \"match\" \"%in%\" \"duplicated\" \"unique\" ...   ..$ : chr [1:2] \"65536\" \"33554432\""},{"path":"https://bit64.r-lib.org/reference/optimizer64.data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit — optimizer64.data","text":"","code":"data(optimizer64.data) print(optimizer64.data) #>            65536      33554432   #> match      numeric,27 numeric,27 #> %in%       numeric,30 numeric,30 #> duplicated numeric,30 numeric,30 #> unique     numeric,45 numeric,45 #> unipos     numeric,42 numeric,42 #> table      numeric,39 numeric,39 #> rank       numeric,21 numeric,21 #> quantile   numeric,18 numeric,18 oldpar <- par(no.readonly = TRUE) par(mfrow=c(2,1)) par(cex=0.7) for (i in 1:nrow(optimizer64.data)){  for (j in 1:2){    tim <- optimizer64.data[[i,j]]   barplot(t(tim))   if (rownames(optimizer64.data)[i]==\"match\")    title(paste(\"match\", colnames(optimizer64.data)[j], \"in\", colnames(optimizer64.data)[3-j]))   else if (rownames(optimizer64.data)[i]==\"%in%\")    title(paste(colnames(optimizer64.data)[j], \"%in%\", colnames(optimizer64.data)[3-j]))   else    title(paste(rownames(optimizer64.data)[i], colnames(optimizer64.data)[j]))  } }         par(mfrow=c(1,1))"},{"path":"https://bit64.r-lib.org/reference/plusclass.html","id":null,"dir":"Reference","previous_headings":"","what":"integer64: Maintaining S3 class attribute — plusclass","title":"integer64: Maintaining S3 class attribute — plusclass","text":"Maintaining integer64 S3 class attribute.","code":""},{"path":"https://bit64.r-lib.org/reference/plusclass.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"integer64: Maintaining S3 class attribute — plusclass","text":"","code":"minusclass(class, whichclass)"},{"path":"https://bit64.r-lib.org/reference/plusclass.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"integer64: Maintaining S3 class attribute — plusclass","text":"class NULL character vector class attributes whichclass (single) class name add remove class vector","code":""},{"path":"https://bit64.r-lib.org/reference/plusclass.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"integer64: Maintaining S3 class attribute — plusclass","text":"NULL character vector class attributes","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/plusclass.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"integer64: Maintaining S3 class attribute — plusclass","text":"","code":"plusclass(\"inheritingclass\",\"integer64\") #> [1] \"inheritingclass\" \"integer64\"         minusclass(c(\"inheritingclass\",\"integer64\"), \"integer64\") #> [1] \"inheritingclass\""},{"path":"https://bit64.r-lib.org/reference/prank.html","id":null,"dir":"Reference","previous_headings":"","what":"(P)ercent (Rank)s — prank","title":"(P)ercent (Rank)s — prank","text":"Function prank.integer64  projects values [min..max] via ranks [1..n] [0..1]. qtile.integer64() inverse function 'prank.integer64' projects [0..1] [min..max].","code":""},{"path":"https://bit64.r-lib.org/reference/prank.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"(P)ercent (Rank)s — prank","text":"","code":"prank(x, ...)  # S3 method for class 'integer64' prank(x, method = NULL, ...)"},{"path":"https://bit64.r-lib.org/reference/prank.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"(P)ercent (Rank)s — prank","text":"x integer64 vector ... ignored method NULL automatic method selection suitable low-level method, see details","code":""},{"path":"https://bit64.r-lib.org/reference/prank.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"(P)ercent (Rank)s — prank","text":"prank returns numeric vector length x.","code":""},{"path":"https://bit64.r-lib.org/reference/prank.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"(P)ercent (Rank)s — prank","text":"Function prank.integer64 based rank.integer64().","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/prank.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"(P)ercent (Rank)s — prank","text":"","code":"x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE)) prank(x) #>  [1] 0.07894737 0.92105263         NA 0.65789474         NA 0.92105263 #>  [7]         NA         NA         NA         NA 0.34210526 0.65789474 #> [13] 0.26315789 0.07894737 0.47368421 0.65789474 0.47368421         NA #> [19]         NA 0.21052632 0.65789474 0.07894737 0.92105263         NA #> [25] 0.92105263         NA 0.07894737 0.47368421         NA 0.34210526 #> [31]         NA 0.78947368  x <- x[!is.na(x)] stopifnot(identical(x,  unname(qtile(x, probs=prank(x)))))"},{"path":"https://bit64.r-lib.org/reference/qtile.html","id":null,"dir":"Reference","previous_headings":"","what":"(Q)uan(Tile)s — qtile","title":"(Q)uan(Tile)s — qtile","text":"Function prank.integer64()  projects values [min..max] via ranks [1..n] [0..1].","code":""},{"path":"https://bit64.r-lib.org/reference/qtile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"(Q)uan(Tile)s — qtile","text":"","code":"qtile(x, probs = seq(0, 1, 0.25), ...)  # S3 method for class 'integer64' qtile(x, probs = seq(0, 1, 0.25), names = TRUE, method = NULL, ...)  # S3 method for class 'integer64' quantile(   x,   probs = seq(0, 1, 0.25),   na.rm = FALSE,   names = TRUE,   type = 0L,   ... )  # S3 method for class 'integer64' median(x, na.rm = FALSE, ...)  # S3 method for class 'integer64' mean(x, na.rm = FALSE, ...)  # S3 method for class 'integer64' summary(object, ...)"},{"path":"https://bit64.r-lib.org/reference/qtile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"(Q)uan(Tile)s — qtile","text":"x integer64 vector probs numeric vector probabilities values [0,1] - possibly containing NAs ... ignored names logical; TRUE, result names attribute. Set FALSE speedup many probs. method NULL automatic method selection suitable low-level method, see details na.rm logical; TRUE, NA NaN's removed x quantiles computed. type integer selecting quantile algorithm, currently 0 supported, see details object integer64 vector","code":""},{"path":"https://bit64.r-lib.org/reference/qtile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"(Q)uan(Tile)s — qtile","text":"prank returns numeric vector length x. qtile returns vector elements x relative positions specified probs.","code":""},{"path":"https://bit64.r-lib.org/reference/qtile.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"(Q)uan(Tile)s — qtile","text":"qtile.ineger64 inverse function 'prank.integer64' projects [0..1] [min..max]. Functions quantile.integer64 type=0 median.integer64 convenience wrappers qtile. Function qtile behaves similar quantile.default type=1 returns existing values, mostly symmetric using 'round' rather 'floor'. Note implies median.integer64 interpolate even number values (interpolation create values represented 64-bit integers). function automatically chooses several low-level functions considering size x availability cache. Suitable methods sortqtl (fast sorting) orderqtl (memory saving ordering).","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/qtile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"(Q)uan(Tile)s — qtile","text":"","code":"x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE)) qtile(x, probs=seq(0, 1, 0.25)) #> integer64 #>   0%  25%  50%  75% 100%  #>    1    3    4    5    6  quantile(x, probs=seq(0, 1, 0.25), na.rm=TRUE) #> integer64 #>   0%  25%  50%  75% 100%  #>    1    3    4    5    6  median(x, na.rm=TRUE) #> integer64 #> [1] 4 summary(x) #> integer64 #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's  #>       1       3       4       3       5       6      16   x <- x[!is.na(x)] stopifnot(identical(x,  unname(qtile(x, probs=prank(x)))))"},{"path":"https://bit64.r-lib.org/reference/ramsort.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Low-level intger64 methods for in-RAM sorting and ordering — ramsort.integer64","title":"Low-level intger64 methods for in-RAM sorting and ordering — ramsort.integer64","text":"Fast low-level methods sorting ordering. ..sortorder methods sorting ordering , requires RAM ordering (almost) fast sorting.","code":""},{"path":"https://bit64.r-lib.org/reference/ramsort.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Low-level intger64 methods for in-RAM sorting and ordering — ramsort.integer64","text":"","code":"# S3 method for class 'integer64' shellsort(x, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)  # S3 method for class 'integer64' shellsortorder(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)  # S3 method for class 'integer64' shellorder(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)  # S3 method for class 'integer64' mergesort(x, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)  # S3 method for class 'integer64' mergeorder(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)  # S3 method for class 'integer64' mergesortorder(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)  # S3 method for class 'integer64' quicksort(   x,   has.na = TRUE,   na.last = FALSE,   decreasing = FALSE,   restlevel = floor(1.5 * log2(length(x))),   ... )  # S3 method for class 'integer64' quicksortorder(   x,   i,   has.na = TRUE,   na.last = FALSE,   decreasing = FALSE,   restlevel = floor(1.5 * log2(length(x))),   ... )  # S3 method for class 'integer64' quickorder(   x,   i,   has.na = TRUE,   na.last = FALSE,   decreasing = FALSE,   restlevel = floor(1.5 * log2(length(x))),   ... )  # S3 method for class 'integer64' radixsort(   x,   has.na = TRUE,   na.last = FALSE,   decreasing = FALSE,   radixbits = 8L,   ... )  # S3 method for class 'integer64' radixsortorder(   x,   i,   has.na = TRUE,   na.last = FALSE,   decreasing = FALSE,   radixbits = 8L,   ... )  # S3 method for class 'integer64' radixorder(   x,   i,   has.na = TRUE,   na.last = FALSE,   decreasing = FALSE,   radixbits = 8L,   ... )  # S3 method for class 'integer64' ramsort(   x,   has.na = TRUE,   na.last = FALSE,   decreasing = FALSE,   stable = TRUE,   optimize = c(\"time\", \"memory\"),   VERBOSE = FALSE,   ... )  # S3 method for class 'integer64' ramsortorder(   x,   i,   has.na = TRUE,   na.last = FALSE,   decreasing = FALSE,   stable = TRUE,   optimize = c(\"time\", \"memory\"),   VERBOSE = FALSE,   ... )  # S3 method for class 'integer64' ramorder(   x,   i,   has.na = TRUE,   na.last = FALSE,   decreasing = FALSE,   stable = TRUE,   optimize = c(\"time\", \"memory\"),   VERBOSE = FALSE,   ... )"},{"path":"https://bit64.r-lib.org/reference/ramsort.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Low-level intger64 methods for in-RAM sorting and ordering — ramsort.integer64","text":"x vector sorted ramsort.integer64() ramsortorder.integer64(), .e. output  sort.integer64() .na boolean scalar defining whether input vector might contain NAs. know NAs, may speed-. Note risk crash unexpected NAs .na=FALSE na.last boolean scalar telling ramsort whether sort NAs last first. Note 'boolean' means third option NA sort() decreasing boolean scalar telling ramsort whether sort increasing decreasing ... arguments, passed generics, ignored methods integer positions modified ramorder.integer64() ramsortorder.integer64(), default 1:n, case output similar order.integer64() restlevel number remaining recursionlevels quicksort switches recursing shellsort radixbits size radix bits stable boolean scalar defining whether stable sorting needed. Allowing non-stable may speed-. optimize default ramsort optimizes 'time' requires RAM, set 'memory' minimize RAM requirements sacrifice speed VERBOSE cat info chosen method","code":""},{"path":"https://bit64.r-lib.org/reference/ramsort.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Low-level intger64 methods for in-RAM sorting and ordering — ramsort.integer64","text":"functions return number NAs found assumed sorting","code":""},{"path":"https://bit64.r-lib.org/reference/ramsort.integer64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Low-level intger64 methods for in-RAM sorting and ordering — ramsort.integer64","text":"See bit::ramsort()","code":""},{"path":"https://bit64.r-lib.org/reference/ramsort.integer64.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Low-level intger64 methods for in-RAM sorting and ordering — ramsort.integer64","text":"Note methods purposely violate functional programming paradigm: called side-effect changing arguments. sort-methods change x, order-methods change , sortoder-methods change x ","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/ramsort.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Low-level intger64 methods for in-RAM sorting and ordering — ramsort.integer64","text":"","code":"x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))   x #> integer64 #>  [1] <NA> 5    <NA> 5    <NA> <NA> 2    8    3    <NA> 3    5    <NA> <NA> #> [15] 4    8    7    <NA> 2    4    <NA> 9    8    6    3    1    2    <NA> #> [29] <NA> <NA> 8    8      message(\"ramsort example\") #> ramsort example   s <- clone(x)   ramsort(s) #> [1] 12   message(\"s has been changed in-place - whether or not ramsort uses an in-place algorithm\") #> s has been changed in-place - whether or not ramsort uses an in-place algorithm   s #> integer64 #>  [1] <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> 1    2    #> [15] 2    2    3    3    3    4    4    5    5    5    6    7    8    8    #> [29] 8    8    8    9      message(\"ramorder example\") #> ramorder example   s <- clone(x)   o <- seq_along(s)   ramorder(s, o) #> [1] 12   message(\"o has been changed in-place - s remains unchanged\") #> o has been changed in-place - s remains unchanged   s #> integer64 #>  [1] <NA> 5    <NA> 5    <NA> <NA> 2    8    3    <NA> 3    5    <NA> <NA> #> [15] 4    8    7    <NA> 2    4    <NA> 9    8    6    3    1    2    <NA> #> [29] <NA> <NA> 8    8      o #>  [1]  1  3  5  6 10 13 14 18 21 28 29 30 26  7 19 27  9 11 25 15 20  2  4 #> [24] 12 24 17  8 16 23 31 32 22   s[o] #> integer64 #>  [1] <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> 1    2    #> [15] 2    2    3    3    3    4    4    5    5    5    6    7    8    8    #> [29] 8    8    8    9      message(\"ramsortorder example\") #> ramsortorder example   o <- seq_along(s)   ramsortorder(s, o) #> [1] 12   message(\"s and o have both been changed in-place - this is much faster\") #> s and o have both been changed in-place - this is much faster   s #> integer64 #>  [1] <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> 1    2    #> [15] 2    2    3    3    3    4    4    5    5    5    6    7    8    8    #> [29] 8    8    8    9      o #>  [1]  1  3  5  6 10 13 14 18 21 28 29 30 26  7 19 27  9 11 25 15 20  2  4 #> [24] 12 24 17  8 16 23 31 32 22"},{"path":"https://bit64.r-lib.org/reference/rank.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample Ranks from integer64 — rank.integer64","title":"Sample Ranks from integer64 — rank.integer64","text":"Returns sample ranks values vector.  Ties (.e., equal values) averaged missing values propagated.","code":""},{"path":"https://bit64.r-lib.org/reference/rank.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample Ranks from integer64 — rank.integer64","text":"","code":"# S3 method for class 'integer64' rank(x, method = NULL, ...)"},{"path":"https://bit64.r-lib.org/reference/rank.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample Ranks from integer64 — rank.integer64","text":"x integer64 vector method NULL automatic method selection suitable low-level method, see details ... ignored","code":""},{"path":"https://bit64.r-lib.org/reference/rank.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample Ranks from integer64 — rank.integer64","text":"numeric vector length x.","code":""},{"path":"https://bit64.r-lib.org/reference/rank.integer64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample Ranks from integer64 — rank.integer64","text":"function automatically chooses several low-level functions considering size x availability cache. Suitable methods sortorderrnk() (fast ordering) orderrnk() (memory saving ordering).","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/rank.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample Ranks from integer64 — rank.integer64","text":"","code":"x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE)) rank.integer64(x) #>  [1] 16.0 11.5  1.5  6.0   NA 11.5 19.5  4.0 19.5   NA 21.0 16.0 11.5   NA #> [15]   NA 16.0  8.5   NA   NA  8.5 11.5   NA  1.5   NA   NA 16.0   NA  4.0 #> [29]  7.0 16.0   NA  4.0  stopifnot(identical(rank.integer64(x),  rank(as.integer(x) , na.last=\"keep\", ties.method = \"average\")))"},{"path":"https://bit64.r-lib.org/reference/rep.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Replicate elements of integer64 vectors — rep.integer64","title":"Replicate elements of integer64 vectors — rep.integer64","text":"Replicate elements integer64 vectors","code":""},{"path":"https://bit64.r-lib.org/reference/rep.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replicate elements of integer64 vectors — rep.integer64","text":"x vector 'integer64' replicated ... arguments passed NextMethod()","code":""},{"path":"https://bit64.r-lib.org/reference/rep.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replicate elements of integer64 vectors — rep.integer64","text":"rep() returns integer64 vector","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/rep.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replicate elements of integer64 vectors — rep.integer64","text":"","code":"rep(as.integer64(1:2), 6) #> integer64 #>  [1] 1 2 1 2 1 2 1 2 1 2 1 2   rep(as.integer64(1:2), c(6,6)) #> integer64 #>  [1] 1 1 1 1 1 1 2 2 2 2 2 2   rep(as.integer64(1:2), length.out=6) #> integer64 #> [1] 1 2 1 2 1 2"},{"path":"https://bit64.r-lib.org/reference/runif64.html","id":null,"dir":"Reference","previous_headings":"","what":"integer64: random numbers — runif64","title":"integer64: random numbers — runif64","text":"Create uniform random 64-bit integers within defined range","code":""},{"path":"https://bit64.r-lib.org/reference/runif64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"integer64: random numbers — runif64","text":"","code":"runif64(   n,   min = lim.integer64()[1L],   max = lim.integer64()[2L],   replace = TRUE )"},{"path":"https://bit64.r-lib.org/reference/runif64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"integer64: random numbers — runif64","text":"n length return vector min lower inclusive bound random numbers max upper inclusive bound random numbers replace set FALSE sampleing finite pool, see sample()","code":""},{"path":"https://bit64.r-lib.org/reference/runif64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"integer64: random numbers — runif64","text":"integer64 vector","code":""},{"path":"https://bit64.r-lib.org/reference/runif64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"integer64: random numbers — runif64","text":"random integer call R's internal C interface unif_rand() twice. call mapped 2^32 unsigned integers. two 32-bit patterns concatenated form new integer64. process repeated result NA_INTEGER64_.","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/runif64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"integer64: random numbers — runif64","text":"","code":"runif64(12) #> integer64 #>  [1] 2915658457812729556  -3491511829406696631 -3496825464828931785 #>  [4] 5395852077839172502  -7835456012596746149 -1516745570522234364 #>  [7] -6832279058283761012 3129987699866411399  -1425688589184971166 #> [10] 1743351634359137850  -619044005758770366  -8343468749812013056   runif64(12, -16, 16) #> integer64 #>  [1] 9   -9  13  8   -10 0   5   14  9   3   -7  -2    runif64(12, 0, as.integer64(2^60)-1)  # not 2^60-1 ! #> integer64 #>  [1] 896499375407589580 799359046121395853 960877807272653955 #>  [4] 733002594872096801 750278469790426764 288656285354523678 #>  [7] 138536448177156874 133560880250517603 449130193256833291 #> [10] 972719265714589958 9862525313230357   403081621054673484   var(runif(1e4)) #> [1] 0.08441354   var(as.double(runif64(1e4, 0, 2^40))/2^40)  # ~ = 1/12 = .08333 #> [1] 0.08380791    table(sample(16, replace=FALSE)) #>  #>  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16  #>  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1    table(runif64(16, 1, 16, replace=FALSE)) #>  #>  2  3  4  5  8 10 11 12 14 15 16  #>  1  2  1  1  1  1  1  3  2  1  2    table(sample(16, replace=TRUE)) #>  #>  1  3  6  8  9 10 12 13 14 15 16  #>  2  1  2  1  1  1  1  2  2  1  2    table(runif64(16, 1, 16, replace=TRUE)) #>  #>  1  2  5  7  8 10 12 13 14 16  #>  1  2  2  1  1  2  2  1  2  2"},{"path":"https://bit64.r-lib.org/reference/seq.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"integer64: Sequence Generation — seq.integer64","title":"integer64: Sequence Generation — seq.integer64","text":"Generating sequence integer64 values","code":""},{"path":"https://bit64.r-lib.org/reference/seq.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"integer64: Sequence Generation — seq.integer64","text":"integer64 scalar (order dispatch integer64 method seq() scalar scalar length.scalar along.scalar ... ignored","code":""},{"path":"https://bit64.r-lib.org/reference/seq.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"integer64: Sequence Generation — seq.integer64","text":"integer64 vector generated sequence","code":""},{"path":"https://bit64.r-lib.org/reference/seq.integer64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"integer64: Sequence Generation — seq.integer64","text":"seq.integer64 coerce arguments '', '' '' integer64. provided, argument '' automatically determined +1 -1, size '' calculated seq() (might result non-integer value).","code":""},{"path":"https://bit64.r-lib.org/reference/seq.integer64.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"integer64: Sequence Generation — seq.integer64","text":"base R : currently generic dispatch, see section \"Limitations inherited Base R\" integer64()","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/seq.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"integer64: Sequence Generation — seq.integer64","text":"","code":"# colon not activated: as.integer64(1):12   seq(as.integer64(1), 12, 2) #> integer64 #> [1] 1  3  5  7  9  11   seq(as.integer64(1), by=2, length.out=6) #> integer64 #> [1] 1  3  5  7  9  11"},{"path":"https://bit64.r-lib.org/reference/sort.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"High-level intger64 methods for sorting and ordering — sort.integer64","title":"High-level intger64 methods for sorting and ordering — sort.integer64","text":"Fast high-level methods sorting ordering. wrappers ramsort.integer64() friends modify arguments.","code":""},{"path":"https://bit64.r-lib.org/reference/sort.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"High-level intger64 methods for sorting and ordering — sort.integer64","text":"","code":"# S3 method for class 'integer64' sort(   x,   decreasing = FALSE,   has.na = TRUE,   na.last = TRUE,   stable = TRUE,   optimize = c(\"time\", \"memory\"),   VERBOSE = FALSE,   ... )  # S3 method for class 'integer64' order(   ...,   na.last = TRUE,   decreasing = FALSE,   has.na = TRUE,   stable = TRUE,   optimize = c(\"time\", \"memory\"),   VERBOSE = FALSE )"},{"path":"https://bit64.r-lib.org/reference/sort.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"High-level intger64 methods for sorting and ordering — sort.integer64","text":"x vector sorted ramsort.integer64() ramsortorder.integer64(), .e. output  sort.integer64() decreasing boolean scalar telling ramsort whether sort increasing decreasing .na boolean scalar defining whether input vector might contain NAs. know NAs, may speed-. Note risk crash unexpected NAs .na=FALSE na.last boolean scalar telling ramsort whether sort NAs last first. Note 'boolean' means third option NA sort() stable boolean scalar defining whether stable sorting needed. Allowing non-stable may speed-. optimize default ramsort optimizes 'time' requires RAM, set 'memory' minimize RAM requirements sacrifice speed VERBOSE cat info chosen method ... arguments, passed generics, ignored methods","code":""},{"path":"https://bit64.r-lib.org/reference/sort.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"High-level intger64 methods for sorting and ordering — sort.integer64","text":"sort returns sorted vector vector returns order positions.","code":""},{"path":"https://bit64.r-lib.org/reference/sort.integer64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"High-level intger64 methods for sorting and ordering — sort.integer64","text":"see sort() order()","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/sort.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"High-level intger64 methods for sorting and ordering — sort.integer64","text":"","code":"x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))   x #> integer64 #>  [1] 9    <NA> 5    1    4    5    <NA> 1    <NA> 1    <NA> <NA> 2    <NA> #> [15] <NA> 5    2    <NA> 7    7    <NA> <NA> 2    5    <NA> 7    <NA> <NA> #> [29] <NA> <NA> 2    <NA>   sort(x) #> integer64 #>  [1] 1    1    1    2    2    2    2    4    5    5    5    5    7    7    #> [15] 7    9    <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> <NA> #> [29] <NA> <NA> <NA> <NA>   message(\"the following has default optimize='time' which is faster but requires more RAM , this calls 'ramorder'\") #> the following has default optimize='time' which is faster but requires more RAM #> , this calls 'ramorder'   order.integer64(x) #>  [1]  4  8 10 13 17 23 31  5  3  6 16 24 19 20 26  1  2  7  9 11 12 14 15 #> [24] 18 21 22 25 27 28 29 30 32   message(\"slower with less RAM, this calls 'ramsortorder'\") #> slower with less RAM, this calls 'ramsortorder'   order.integer64(x, optimize=\"memory\") #>  [1]  4  8 10 13 17 23 31  5  3  6 16 24 19 20 26  1  2  7  9 11 12 14 15 #> [24] 18 21 22 25 27 28 29 30 32"},{"path":"https://bit64.r-lib.org/reference/sortnut.html","id":null,"dir":"Reference","previous_headings":"","what":"Searching and other uses of sorting for 64bit integers — sortnut","title":"Searching and other uses of sorting for 64bit integers — sortnut","text":"roughly implementation hash functionality based sorting instead hashmap. Since sorting informative hashing can interesting things.","code":""},{"path":"https://bit64.r-lib.org/reference/sortnut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Searching and other uses of sorting for 64bit integers — sortnut","text":"","code":"sortnut(sorted, ...)  # S3 method for class 'integer64' sortnut(sorted, ...)  ordernut(table, order, ...)  # S3 method for class 'integer64' ordernut(table, order, ...)  sortfin(sorted, x, ...)  # S3 method for class 'integer64' sortfin(sorted, x, method = NULL, ...)  orderfin(table, order, x, ...)  # S3 method for class 'integer64' orderfin(table, order, x, method = NULL, ...)  orderpos(table, order, x, ...)  # S3 method for class 'integer64' orderpos(table, order, x, nomatch = NA, method = NULL, ...)  sortorderpos(sorted, order, x, ...)  # S3 method for class 'integer64' sortorderpos(sorted, order, x, nomatch = NA, method = NULL, ...)  orderdup(table, order, ...)  # S3 method for class 'integer64' orderdup(table, order, method = NULL, ...)  sortorderdup(sorted, order, ...)  # S3 method for class 'integer64' sortorderdup(sorted, order, method = NULL, ...)  sortuni(sorted, nunique, ...)  # S3 method for class 'integer64' sortuni(sorted, nunique, ...)  orderuni(table, order, nunique, ...)  # S3 method for class 'integer64' orderuni(table, order, nunique, keep.order = FALSE, ...)  sortorderuni(table, sorted, order, nunique, ...)  # S3 method for class 'integer64' sortorderuni(table, sorted, order, nunique, ...)  orderupo(table, order, nunique, ...)  # S3 method for class 'integer64' orderupo(table, order, nunique, keep.order = FALSE, ...)  sortorderupo(sorted, order, nunique, keep.order = FALSE, ...)  # S3 method for class 'integer64' sortorderupo(sorted, order, nunique, keep.order = FALSE, ...)  ordertie(table, order, nties, ...)  # S3 method for class 'integer64' ordertie(table, order, nties, ...)  sortordertie(sorted, order, nties, ...)  # S3 method for class 'integer64' sortordertie(sorted, order, nties, ...)  sorttab(sorted, nunique, ...)  # S3 method for class 'integer64' sorttab(sorted, nunique, ...)  ordertab(table, order, nunique, ...)  # S3 method for class 'integer64' ordertab(table, order, nunique, denormalize = FALSE, keep.order = FALSE, ...)  sortordertab(sorted, order, ...)  # S3 method for class 'integer64' sortordertab(sorted, order, denormalize = FALSE, ...)  orderkey(table, order, na.skip.num = 0L, ...)  # S3 method for class 'integer64' orderkey(table, order, na.skip.num = 0L, ...)  sortorderkey(sorted, order, na.skip.num = 0L, ...)  # S3 method for class 'integer64' sortorderkey(sorted, order, na.skip.num = 0L, ...)  orderrnk(table, order, na.count, ...)  # S3 method for class 'integer64' orderrnk(table, order, na.count, ...)  sortorderrnk(sorted, order, na.count, ...)  # S3 method for class 'integer64' sortorderrnk(sorted, order, na.count, ...)  sortqtl(sorted, na.count, probs, ...)  # S3 method for class 'integer64' sortqtl(sorted, na.count, probs, ...)  orderqtl(table, order, na.count, probs, ...)  # S3 method for class 'integer64' orderqtl(table, order, na.count, probs, ...)"},{"path":"https://bit64.r-lib.org/reference/sortnut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Searching and other uses of sorting for 64bit integers — sortnut","text":"sorted sorted integer64 vector ... arguments, passed generics, ignored methods table original data original order sorted vector order integer order vector turns 'table' 'sorted' x integer64 vector method see Details nomatch value returned element found hashmap nunique number unique elements, usually get cache call sortnut ordernut keep.order determines order results speed: FALSE (default) faster returns sorted order, TRUE returns order first appearance original data, requires extra work nties number tied values, usually get cache call sortnut ordernut denormalize FALSE returns counts unique values, TRUE returns value counts na.skip.num 0 number NAs. 0, NAs coded 1L, number NAs, coded NA na.count number NAs, needed low-level function algorithm probs vector probabilities [0..1] seek quantiles","code":""},{"path":"https://bit64.r-lib.org/reference/sortnut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Searching and other uses of sorting for 64bit integers — sortnut","text":"see details","code":""},{"path":"https://bit64.r-lib.org/reference/sortnut.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Searching and other uses of sorting for 64bit integers — sortnut","text":"functions sortfin, orderfin, orderpos sortorderpos offer three algorithms finding x table. method=1L value x searched independently using binary search, fastest small tables. method=2L values x first sorted searched using doubly exponential search, best allround method. method=3L values x first sorted searched using simple merging, fastest method table huge x similar size distribution values. method=NULL functions use heuristic determine fastest algorithm. functions orderdup sortorderdup offer two algorithms setting truth values return vector. method=1L return values set directly causes random write access possibly large return vector. method=2L return values first set smaller bit-vector – random access limited smaller memory region – finally written sequentially logical output  vector. method=NULL functions use heuristic determine fastest algorithm.","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/sortnut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Searching and other uses of sorting for 64bit integers — sortnut","text":"","code":"message(\"check the code of 'optimizer64' for examples:\") #> check the code of 'optimizer64' for examples:  print(optimizer64) #> function (nsmall = 2L^16L, nbig = 2L^25L, timefun = repeat.time,  #>     what = c(\"match\", \"%in%\", \"duplicated\", \"unique\", \"unipos\",  #>         \"table\", \"rank\", \"quantile\"), uniorder = c(\"original\",  #>         \"values\", \"any\"), taborder = c(\"values\", \"counts\"), plot = TRUE)  #> { #>     uniorder <- match.arg(uniorder) #>     taborder <- match.arg(taborder) #>     ret <- vector(\"list\", 2L * length(what)) #>     dim(ret) <- c(length(what), 2L) #>     dimnames(ret) <- list(what, c(nsmall, nbig)) #>     if (plot) { #>         oldpar <- par(no.readonly = TRUE) #>         on.exit(par(oldpar)) #>         par(mfrow = c(2L, 1L)) #>     } #>     if (\"match\" %in% what) { #>         message(\"match: timings of different methods\") #>         N1 <- c(nsmall, nbig) #>         N2 <- c(nbig, nsmall) #>         for (i in seq_along(N1)) { #>             n1 <- N1[i] #>             n2 <- N2[i] #>             x1 <- c(sample(n2, n1 - 1L, TRUE), NA) #>             x2 <- c(sample(n2, n2 - 1L, TRUE), NA) #>             tim <- matrix(0, 9L, 3L) #>             dimnames(tim) <- list(c(\"match\", \"match.64\", \"hashpos\",  #>                 \"hashrev\", \"sortorderpos\", \"orderpos\", \"hashcache\",  #>                 \"sortorder.cache\", \"order.cache\"), c(\"prep\",  #>                 \"both\", \"use\")) #>             tim[\"match\", \"both\"] <- timefun({ #>                 p <- match(x1, x2) #>             })[3L] #>             x1 <- as.integer64(x1) #>             x2 <- as.integer64(x2) #>             tim[\"match.64\", \"both\"] <- timefun({ #>                 p2 <- match.integer64(x1, x2) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"hashpos\", \"prep\"] <- timefun({ #>                 h2 <- hashmap(x2) #>             })[3L] #>             tim[\"hashpos\", \"use\"] <- timefun({ #>                 p2 <- hashpos(h2, x1) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"hashrev\", \"prep\"] <- timefun({ #>                 h1 <- hashmap(x1) #>             })[3L] #>             tim[\"hashrev\", \"use\"] <- timefun({ #>                 p1 <- hashrev(h1, x2) #>             })[3L] #>             stopifnot(identical(p1, p)) #>             tim[\"sortorderpos\", \"prep\"] <- system.time({ #>                 s2 <- clone(x2) #>                 o2 <- seq_along(x2) #>                 ramsortorder(s2, o2, na.last = FALSE) #>             })[3L] #>             tim[\"sortorderpos\", \"use\"] <- timefun({ #>                 p2 <- sortorderpos(s2, o2, x1) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"orderpos\", \"prep\"] <- timefun({ #>                 o2 <- seq_along(x2) #>                 ramorder(x2, o2, na.last = FALSE) #>             })[3L] #>             tim[\"orderpos\", \"use\"] <- timefun({ #>                 p2 <- orderpos(x2, o2, x1, method = 2L) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             hashcache(x2) #>             tim[\"hashcache\", \"use\"] <- timefun({ #>                 p2 <- match.integer64(x1, x2) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x2) #>             sortordercache(x2) #>             tim[\"sortorder.cache\", \"use\"] <- timefun({ #>                 p2 <- match.integer64(x1, x2) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x2) #>             ordercache(x2) #>             tim[\"order.cache\", \"use\"] <- timefun({ #>                 p2 <- match.integer64(x1, x2) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x2) #>             if (plot) { #>                 barplot(t(tim)) #>                 n <- format(c(n1, n2)) #>                 title(paste(\"match\", n[1L], \"in\", n[2L])) #>             } #>             ret[[\"match\", as.character(n1)]] <- tim #>         } #>     } #>     if (\"%in%\" %in% what) { #>         message(\"%in%: timings of different methods\") #>         N1 <- c(nsmall, nbig) #>         N2 <- c(nbig, nsmall) #>         for (i in seq_along(N1)) { #>             n1 <- N1[i] #>             n2 <- N2[i] #>             x1 <- c(sample(n2, n1 - 1L, TRUE), NA) #>             x2 <- c(sample(n2, n2 - 1L, TRUE), NA) #>             tim <- matrix(0, 10L, 3L) #>             dimnames(tim) <- list(c(\"%in%\", \"match.64\", \"%in%.64\",  #>                 \"hashfin\", \"hashrin\", \"sortfin\", \"orderfin\",  #>                 \"hash.cache\", \"sortorder.cache\", \"order.cache\"),  #>                 c(\"prep\", \"both\", \"use\")) #>             tim[\"%in%\", \"both\"] <- timefun({ #>                 p <- x1 %in% x2 #>             })[3L] #>             x1 <- as.integer64(x1) #>             x2 <- as.integer64(x2) #>             tim[\"match.64\", \"both\"] <- timefun({ #>                 p2 <- match.integer64(x1, x2, nomatch = 0L) >  #>                   0L #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"%in%.64\", \"both\"] <- timefun({ #>                 p2 <- `%in%.integer64`(x1, x2) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"hashfin\", \"prep\"] <- timefun({ #>                 h2 <- hashmap(x2) #>             })[3L] #>             tim[\"hashfin\", \"use\"] <- timefun({ #>                 p2 <- hashfin(h2, x1) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"hashrin\", \"prep\"] <- timefun({ #>                 h1 <- hashmap(x1) #>             })[3L] #>             tim[\"hashrin\", \"use\"] <- timefun({ #>                 p1 <- hashrin(h1, x2) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"sortfin\", \"prep\"] <- timefun({ #>                 s2 <- clone(x2) #>                 ramsort(s2, na.last = FALSE) #>             })[3L] #>             tim[\"sortfin\", \"use\"] <- timefun({ #>                 p2 <- sortfin(s2, x1) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"orderfin\", \"prep\"] <- timefun({ #>                 o2 <- seq_along(x2) #>                 ramorder(x2, o2, na.last = FALSE) #>             })[3L] #>             tim[\"orderfin\", \"use\"] <- timefun({ #>                 p2 <- orderfin(x2, o2, x1) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             hashcache(x2) #>             tim[\"hash.cache\", \"use\"] <- timefun({ #>                 p2 <- `%in%.integer64`(x1, x2) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x2) #>             sortordercache(x2) #>             tim[\"sortorder.cache\", \"use\"] <- timefun({ #>                 p2 <- `%in%.integer64`(x1, x2) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x2) #>             ordercache(x2) #>             tim[\"order.cache\", \"use\"] <- timefun({ #>                 p2 <- `%in%.integer64`(x1, x2) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x2) #>             if (plot) { #>                 barplot(t(tim)) #>                 n <- format(c(n1, n2)) #>                 title(paste(n[1L], \"%in%\", n[2L])) #>             } #>             ret[[\"%in%\", as.character(n1)]] <- tim #>         } #>     } #>     if (\"duplicated\" %in% what) { #>         message(\"duplicated: timings of different methods\") #>         N <- c(nsmall, nbig) #>         for (i in seq_along(N)) { #>             n <- N[i] #>             x <- c(sample(n, n - 1L, TRUE), NA) #>             tim <- matrix(0, 10L, 3L) #>             dimnames(tim) <- list(c(\"duplicated\", \"duplicated.64\",  #>                 \"hashdup\", \"sortorderdup1\", \"sortorderdup2\",  #>                 \"orderdup1\", \"orderdup2\", \"hash.cache\", \"sortorder.cache\",  #>                 \"order.cache\"), c(\"prep\", \"both\", \"use\")) #>             tim[\"duplicated\", \"both\"] <- timefun({ #>                 p <- duplicated(x) #>             })[3L] #>             x <- as.integer64(x) #>             tim[\"duplicated.64\", \"both\"] <- timefun({ #>                 p2 <- duplicated(x) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"hashdup\", \"prep\"] <- timefun({ #>                 h <- hashmap(x) #>             })[3L] #>             tim[\"hashdup\", \"use\"] <- timefun({ #>                 p2 <- hashdup(h) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"sortorderdup1\", \"prep\"] <- timefun({ #>                 s <- clone(x) #>                 o <- seq_along(x) #>                 ramsortorder(s, o, na.last = FALSE) #>                 nunique <- sortnut(s)[1L] #>             })[3L] #>             tim[\"sortorderdup1\", \"use\"] <- timefun({ #>                 p2 <- sortorderdup(s, o, method = 1L) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"sortorderdup2\", \"prep\"] <- tim[\"sortorderdup1\",  #>                 \"prep\"] #>             tim[\"sortorderdup2\", \"use\"] <- timefun({ #>                 p2 <- sortorderdup(s, o, method = 2L) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"orderdup1\", \"prep\"] <- timefun({ #>                 o <- seq_along(x) #>                 ramorder(x, o, na.last = FALSE) #>                 nunique <- ordernut(x, o)[1L] #>             })[3L] #>             tim[\"orderdup1\", \"use\"] <- timefun({ #>                 p2 <- orderdup(x, o, method = 1L) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"orderdup2\", \"prep\"] <- tim[\"orderdup1\", \"prep\"] #>             tim[\"orderdup2\", \"use\"] <- timefun({ #>                 p2 <- orderdup(x, o, method = 2L) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             hashcache(x) #>             tim[\"hash.cache\", \"use\"] <- timefun({ #>                 p2 <- duplicated(x) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x) #>             sortordercache(x) #>             tim[\"sortorder.cache\", \"use\"] <- timefun({ #>                 p2 <- duplicated(x) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x) #>             ordercache(x) #>             tim[\"order.cache\", \"use\"] <- timefun({ #>                 p2 <- duplicated(x) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x) #>             if (plot) { #>                 barplot(t(tim), cex.names = 0.7) #>                 title(paste0(\"duplicated(\", n, \")\")) #>             } #>             ret[[\"duplicated\", as.character(n)]] <- tim #>         } #>     } #>     if (\"unique\" %in% what) { #>         message(\"unique: timings of different methods\") #>         N <- c(nsmall, nbig) #>         for (i in seq_along(N)) { #>             n <- N[i] #>             x <- c(sample(n, n - 1L, TRUE), NA) #>             tim <- matrix(0, 15L, 3L) #>             dimnames(tim) <- list(c(\"unique\", \"unique.64\", \"hashmapuni\",  #>                 \"hashuni\", \"hashunikeep\", \"sortuni\", \"sortunikeep\",  #>                 \"orderuni\", \"orderunikeep\", \"hashdup\", \"sortorderdup\",  #>                 \"hash.cache\", \"sort.cache\", \"sortorder.cache\",  #>                 \"order.cache\"), c(\"prep\", \"both\", \"use\")) #>             tim[\"unique\", \"both\"] <- timefun({ #>                 p <- unique(x) #>             })[3L] #>             x <- as.integer64(x) #>             p <- as.integer64(p) #>             if (uniorder == \"values\")  #>                 ramsort(p, na.last = FALSE) #>             tim[\"unique.64\", \"both\"] <- timefun({ #>                 p2 <- unique(x, order = uniorder) #>             })[3L] #>             if (uniorder != \"any\")  #>                 stopifnot(identical.integer64(p2, p)) #>             tim[\"hashmapuni\", \"both\"] <- timefun({ #>                 p2 <- hashmapuni(x) #>             })[3L] #>             if (uniorder == \"original\")  #>                 stopifnot(identical.integer64(p2, p)) #>             tim[\"hashuni\", \"prep\"] <- timefun({ #>                 h <- hashmap(x) #>             })[3L] #>             tim[\"hashuni\", \"use\"] <- timefun({ #>                 p2 <- hashuni(h) #>             })[3L] #>             if (uniorder == \"values\")  #>                 stopifnot(identical.integer64(sort(p2, na.last = FALSE),  #>                   p)) #>             tim[\"hashunikeep\", \"prep\"] <- tim[\"hashuni\", \"prep\"] #>             tim[\"hashunikeep\", \"use\"] <- timefun({ #>                 p2 <- hashuni(h, keep.order = TRUE) #>             })[3L] #>             if (uniorder == \"original\")  #>                 stopifnot(identical.integer64(p2, p)) #>             tim[\"sortuni\", \"prep\"] <- timefun({ #>                 s <- clone(x) #>                 ramsort(s, na.last = FALSE) #>                 nunique <- sortnut(s)[1L] #>             })[3L] #>             tim[\"sortuni\", \"use\"] <- timefun({ #>                 p2 <- sortuni(s, nunique) #>             })[3L] #>             if (uniorder == \"values\")  #>                 stopifnot(identical.integer64(sort(p2, na.last = FALSE),  #>                   p)) #>             tim[\"sortunikeep\", \"prep\"] <- timefun({ #>                 s <- clone(x) #>                 o <- seq_along(x) #>                 ramsortorder(s, o, na.last = FALSE) #>                 nunique <- sortnut(s)[1L] #>             })[3L] #>             tim[\"sortunikeep\", \"use\"] <- timefun({ #>                 p2 <- sortorderuni(x, s, o, nunique) #>             })[3L] #>             if (uniorder == \"original\")  #>                 stopifnot(identical.integer64(p2, p)) #>             tim[\"orderuni\", \"prep\"] <- timefun({ #>                 o <- seq_along(x) #>                 ramorder(x, o, na.last = FALSE) #>                 nunique <- ordernut(x, o)[1L] #>             })[3L] #>             tim[\"orderuni\", \"use\"] <- timefun({ #>                 p2 <- orderuni(x, o, nunique) #>             })[3L] #>             if (uniorder == \"values\")  #>                 stopifnot(identical.integer64(sort(p2, na.last = FALSE),  #>                   p)) #>             tim[\"orderunikeep\", \"prep\"] <- tim[\"orderuni\", \"prep\"] #>             tim[\"orderunikeep\", \"use\"] <- timefun({ #>                 p2 <- orderuni(x, o, nunique, keep.order = TRUE) #>                 nunique <- ordernut(x, o)[1L] #>             })[3L] #>             if (uniorder == \"original\")  #>                 stopifnot(identical.integer64(p2, p)) #>             tim[\"hashdup\", \"prep\"] <- tim[\"hashuni\", \"prep\"] #>             tim[\"hashdup\", \"use\"] <- timefun({ #>                 p2 <- x[!hashdup(h)] #>             })[3L] #>             if (uniorder == \"original\")  #>                 stopifnot(identical.integer64(p2, p)) #>             tim[\"sortorderdup\", \"prep\"] <- tim[\"sortunikeep\",  #>                 \"prep\"] #>             tim[\"sortorderdup\", \"use\"] <- timefun({ #>                 p2 <- x[!sortorderdup(s, o)] #>             })[3L] #>             if (uniorder == \"original\")  #>                 stopifnot(identical.integer64(p2, p)) #>             hashcache(x) #>             tim[\"hash.cache\", \"use\"] <- timefun({ #>                 p2 <- unique(x, order = uniorder) #>             })[3L] #>             if (uniorder != \"any\")  #>                 stopifnot(identical.integer64(p2, p)) #>             remcache(x) #>             sortcache(x) #>             tim[\"sort.cache\", \"use\"] <- timefun({ #>                 p2 <- unique(x, order = uniorder) #>             })[3L] #>             if (uniorder != \"any\")  #>                 stopifnot(identical.integer64(p2, p)) #>             remcache(x) #>             sortordercache(x) #>             tim[\"sortorder.cache\", \"use\"] <- timefun({ #>                 p2 <- unique(x, order = uniorder) #>             })[3L] #>             if (uniorder != \"any\")  #>                 stopifnot(identical.integer64(p2, p)) #>             remcache(x) #>             ordercache(x) #>             tim[\"order.cache\", \"use\"] <- timefun({ #>                 p2 <- unique(x, order = uniorder) #>             })[3L] #>             if (uniorder != \"any\")  #>                 stopifnot(identical.integer64(p2, p)) #>             remcache(x) #>             if (plot) { #>                 barplot(t(tim), cex.names = 0.7) #>                 title(paste0(\"unique(\", n, \", order=\", uniorder,  #>                   \")\")) #>             } #>             ret[[\"unique\", as.character(n)]] <- tim #>         } #>     } #>     if (\"unipos\" %in% what) { #>         message(\"unipos: timings of different methods\") #>         N <- c(nsmall, nbig) #>         for (i in seq_along(N)) { #>             n <- N[i] #>             x <- c(sample(n, n - 1L, TRUE), NA) #>             tim <- matrix(0, 14L, 3L) #>             dimnames(tim) <- list(c(\"unique\", \"unipos.64\", \"hashmapupo\",  #>                 \"hashupo\", \"hashupokeep\", \"sortorderupo\", \"sortorderupokeep\",  #>                 \"orderupo\", \"orderupokeep\", \"hashdup\", \"sortorderdup\",  #>                 \"hash.cache\", \"sortorder.cache\", \"order.cache\"),  #>                 c(\"prep\", \"both\", \"use\")) #>             tim[\"unique\", \"both\"] <- timefun({ #>                 unique(x) #>             })[3L] #>             x <- as.integer64(x) #>             tim[\"unipos.64\", \"both\"] <- timefun({ #>                 p <- unipos(x, order = uniorder) #>             })[3L] #>             tim[\"hashmapupo\", \"both\"] <- timefun({ #>                 p2 <- hashmapupo(x) #>             })[3L] #>             if (uniorder == \"original\")  #>                 stopifnot(identical(p2, p)) #>             tim[\"hashupo\", \"prep\"] <- timefun({ #>                 h <- hashmap(x) #>             })[3L] #>             tim[\"hashupo\", \"use\"] <- timefun({ #>                 p2 <- hashupo(h) #>             })[3L] #>             if (uniorder == \"values\")  #>                 stopifnot(identical(sort(p2, na.last = FALSE),  #>                   sort(p, na.last = FALSE))) #>             tim[\"hashupokeep\", \"prep\"] <- tim[\"hashupo\", \"prep\"] #>             tim[\"hashupokeep\", \"use\"] <- timefun({ #>                 p2 <- hashupo(h, keep.order = TRUE) #>             })[3L] #>             if (uniorder == \"original\")  #>                 stopifnot(identical(p2, p)) #>             tim[\"sortorderupo\", \"prep\"] <- timefun({ #>                 s <- clone(x) #>                 o <- seq_along(x) #>                 ramsortorder(s, o, na.last = FALSE) #>                 nunique <- sortnut(s)[1L] #>             })[3L] #>             tim[\"sortorderupo\", \"use\"] <- timefun({ #>                 p2 <- sortorderupo(s, o, nunique) #>             })[3L] #>             if (uniorder == \"values\")  #>                 stopifnot(identical(p2, p)) #>             tim[\"sortorderupokeep\", \"prep\"] <- timefun({ #>                 s <- clone(x) #>                 o <- seq_along(x) #>                 ramsortorder(s, o, na.last = FALSE) #>                 nunique <- sortnut(s)[1L] #>             })[3L] #>             tim[\"sortorderupokeep\", \"use\"] <- timefun({ #>                 p2 <- sortorderupo(s, o, nunique, keep.order = TRUE) #>             })[3L] #>             if (uniorder == \"original\")  #>                 stopifnot(identical(p2, p)) #>             tim[\"orderupo\", \"prep\"] <- timefun({ #>                 o <- seq_along(x) #>                 ramorder(x, o, na.last = FALSE) #>                 nunique <- ordernut(x, o)[1L] #>             })[3L] #>             tim[\"orderupo\", \"use\"] <- timefun({ #>                 p2 <- orderupo(x, o, nunique) #>             })[3L] #>             if (uniorder == \"values\")  #>                 stopifnot(identical(p2, p)) #>             tim[\"orderupokeep\", \"prep\"] <- tim[\"orderupo\", \"prep\"] #>             tim[\"orderupokeep\", \"use\"] <- timefun({ #>                 p2 <- orderupo(x, o, nunique, keep.order = TRUE) #>                 nunique <- ordernut(x, o)[1L] #>             })[3L] #>             if (uniorder == \"original\")  #>                 stopifnot(identical(p2, p)) #>             tim[\"hashdup\", \"prep\"] <- tim[\"hashupo\", \"prep\"] #>             tim[\"hashdup\", \"use\"] <- timefun({ #>                 p2 <- (1:n)[!hashdup(h)] #>             })[3L] #>             if (uniorder == \"original\")  #>                 stopifnot(identical(p2, p)) #>             tim[\"sortorderdup\", \"prep\"] <- tim[\"sortorderupokeep\",  #>                 \"prep\"] #>             tim[\"sortorderdup\", \"use\"] <- timefun({ #>                 p2 <- (1:n)[!sortorderdup(s, o)] #>             })[3L] #>             if (uniorder == \"original\")  #>                 stopifnot(identical(p2, p)) #>             hashcache(x) #>             tim[\"hash.cache\", \"use\"] <- timefun({ #>                 p2 <- unipos(x, order = uniorder) #>             })[3L] #>             if (uniorder != \"any\")  #>                 stopifnot(identical(p2, p)) #>             remcache(x) #>             sortordercache(x) #>             tim[\"sortorder.cache\", \"use\"] <- timefun({ #>                 p2 <- unipos(x, order = uniorder) #>             })[3L] #>             if (uniorder != \"any\")  #>                 stopifnot(identical(p2, p)) #>             remcache(x) #>             ordercache(x) #>             tim[\"order.cache\", \"use\"] <- timefun({ #>                 p2 <- unipos(x, order = uniorder) #>             })[3L] #>             if (uniorder != \"any\")  #>                 stopifnot(identical(p2, p)) #>             remcache(x) #>             if (plot) { #>                 barplot(t(tim), cex.names = 0.7) #>                 title(paste0(\"unipos(\", n, \", order=\", uniorder,  #>                   \")\")) #>             } #>             ret[[\"unipos\", as.character(n)]] <- tim #>         } #>     } #>     if (\"table\" %in% what) { #>         message(\"table: timings of different methods\") #>         N <- c(nsmall, nbig) #>         for (i in seq_along(N)) { #>             n <- N[i] #>             x <- c(sample.int(1024L, n - 1L, replace = TRUE),  #>                 NA) #>             tim <- matrix(0, 13L, 3L) #>             dimnames(tim) <- list(c(\"tabulate\", \"table\", \"table.64\",  #>                 \"hashmaptab\", \"hashtab\", \"hashtab2\", \"sorttab\",  #>                 \"sortordertab\", \"ordertab\", \"ordertabkeep\", \"hash.cache\",  #>                 \"sort.cache\", \"order.cache\"), c(\"prep\", \"both\",  #>                 \"use\")) #>             tim[\"tabulate\", \"both\"] <- timefun({ #>                 tabulate(x) #>             })[3L] #>             tim[\"table\", \"both\"] <- timefun({ #>                 p <- table(x, exclude = NULL) #>             })[3L] #>             p <- p[-length(p)] #>             x <- as.integer64(x) #>             tim[\"table.64\", \"both\"] <- timefun({ #>                 p2 <- table.integer64(x, order = taborder) #>             })[3L] #>             p2 <- p2[-1L] #>             stopifnot(identical(p2, p)) #>             tim[\"hashmaptab\", \"both\"] <- timefun({ #>                 p <- hashmaptab(x) #>             })[3L] #>             tim[\"hashtab\", \"prep\"] <- timefun({ #>                 h <- hashmap(x) #>             })[3L] #>             tim[\"hashtab\", \"use\"] <- timefun({ #>                 p2 <- hashtab(h) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"hashtab2\", \"prep\"] <- tim[\"hashtab\", \"prep\"] +  #>                 timefun({ #>                   h <- hashmap(x, nunique = h$nunique) #>                 })[3L] #>             tim[\"hashtab2\", \"use\"] <- timefun({ #>                 p2 <- hashtab(h) #>             })[3L] #>             sortp <- function(p) { #>                 s <- p$values #>                 o <- seq_along(s) #>                 ramsortorder(s, o, na.last = FALSE) #>                 list(values = s, counts = p$counts[o]) #>             } #>             p <- sortp(p) #>             p2 <- sortp(p2) #>             stopifnot(identical(p2, p)) #>             tim[\"sorttab\", \"prep\"] <- timefun({ #>                 s <- clone(x) #>                 ramsort(s, na.last = FALSE) #>                 nunique <- sortnut(s)[1L] #>             })[3L] #>             tim[\"sorttab\", \"use\"] <- timefun({ #>                 p2 <- list(values = sortuni(s, nunique), counts = sorttab(s,  #>                   nunique)) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"sortordertab\", \"prep\"] <- timefun({ #>                 s <- clone(x) #>                 o <- seq_along(x) #>                 ramsortorder(s, o, na.last = FALSE) #>                 nunique <- sortnut(s)[1L] #>             })[3L] #>             tim[\"sortordertab\", \"use\"] <- timefun({ #>                 p2 <- list(values = sortorderuni(x, s, o, nunique),  #>                   counts = sortordertab(s, o)) #>             })[3L] #>             p2 <- sortp(p2) #>             stopifnot(identical(p2, p)) #>             tim[\"ordertab\", \"prep\"] <- timefun({ #>                 o <- seq_along(x) #>                 ramorder(x, o, na.last = FALSE) #>                 nunique <- ordernut(x, o)[1L] #>             })[3L] #>             tim[\"ordertab\", \"use\"] <- timefun({ #>                 p2 <- list(values = orderuni(x, o, nunique),  #>                   counts = ordertab(x, o, nunique)) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"ordertabkeep\", \"prep\"] <- tim[\"ordertab\", \"prep\"] #>             tim[\"ordertabkeep\", \"use\"] <- timefun({ #>                 p2 <- list(values = orderuni(x, o, nunique, keep.order = TRUE),  #>                   counts = ordertab(x, o, nunique, keep.order = TRUE)) #>             })[3L] #>             p2 <- sortp(p2) #>             stopifnot(identical(p2, p)) #>             hashcache(x) #>             tim[\"hash.cache\", \"use\"] <- timefun({ #>                 p <- table.integer64(x, order = taborder) #>             })[3L] #>             remcache(x) #>             sortordercache(x) #>             tim[\"sort.cache\", \"use\"] <- timefun({ #>                 p2 <- table.integer64(x, order = taborder) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x) #>             ordercache(x) #>             tim[\"order.cache\", \"use\"] <- timefun({ #>                 p2 <- table.integer64(x, order = taborder) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x) #>             if (plot) { #>                 barplot(t(tim), cex.names = 0.7) #>                 title(paste0(\"table.integer64(\", n, \", order=\",  #>                   taborder, \")\")) #>             } #>             ret[[\"table\", as.character(n)]] <- tim #>         } #>     } #>     if (\"rank\" %in% what) { #>         message(\"rank: timings of different methods\") #>         N <- c(nsmall, nbig) #>         for (i in seq_along(N)) { #>             n <- N[i] #>             x <- c(sample(n, n - 1L, TRUE), NA) #>             tim <- matrix(0, 7L, 3L) #>             dimnames(tim) <- list(c(\"rank\", \"rank.keep\", \"rank.64\",  #>                 \"sortorderrnk\", \"orderrnk\", \"sort.cache\", \"order.cache\"),  #>                 c(\"prep\", \"both\", \"use\")) #>             tim[\"rank\", \"both\"] <- timefun({ #>                 rank(x) #>             })[3L] #>             tim[\"rank.keep\", \"both\"] <- timefun({ #>                 p <- rank(x, na.last = \"keep\") #>             })[3L] #>             x <- as.integer64(x) #>             tim[\"rank.64\", \"both\"] <- timefun({ #>                 p2 <- rank.integer64(x) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"sortorderrnk\", \"prep\"] <- timefun({ #>                 s <- clone(x) #>                 o <- seq_along(x) #>                 na.count <- ramsortorder(s, o, na.last = FALSE) #>             })[3L] #>             tim[\"sortorderrnk\", \"use\"] <- timefun({ #>                 p2 <- sortorderrnk(s, o, na.count) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"orderrnk\", \"prep\"] <- timefun({ #>                 o <- seq_along(x) #>                 na.count <- ramorder(x, o, na.last = FALSE) #>             })[3L] #>             tim[\"orderrnk\", \"use\"] <- timefun({ #>                 p2 <- orderrnk(x, o, na.count) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             sortordercache(x) #>             tim[\"sort.cache\", \"use\"] <- timefun({ #>                 p2 <- rank.integer64(x) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x) #>             ordercache(x) #>             tim[\"order.cache\", \"use\"] <- timefun({ #>                 p2 <- rank.integer64(x) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x) #>             if (plot) { #>                 barplot(t(tim), cex.names = 0.7) #>                 title(paste0(\"rank.integer64(\", n, \")\")) #>             } #>             ret[[\"rank\", as.character(n)]] <- tim #>         } #>     } #>     if (\"quantile\" %in% what) { #>         message(\"quantile: timings of different methods\") #>         N <- c(nsmall, nbig) #>         for (i in seq_along(N)) { #>             n <- N[i] #>             x <- c(sample(n, n - 1L, TRUE), NA) #>             tim <- matrix(0, 6L, 3L) #>             dimnames(tim) <- list(c(\"quantile\", \"quantile.64\",  #>                 \"sortqtl\", \"orderqtl\", \"sort.cache\", \"order.cache\"),  #>                 c(\"prep\", \"both\", \"use\")) #>             tim[\"quantile\", \"both\"] <- timefun({ #>                 p <- quantile(x, type = 1L, na.rm = TRUE) #>             })[3L] #>             p2 <- p #>             p <- as.integer64(p2) #>             names(p) <- names(p2) #>             x <- as.integer64(x) #>             tim[\"quantile.64\", \"both\"] <- timefun({ #>                 p2 <- quantile(x, na.rm = TRUE) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             tim[\"sortqtl\", \"prep\"] <- timefun({ #>                 s <- clone(x) #>                 na.count <- ramsort(s, na.last = FALSE) #>             })[3L] #>             tim[\"sortqtl\", \"use\"] <- timefun({ #>                 p2 <- sortqtl(s, na.count, seq(0, 1, 0.25)) #>             })[3L] #>             stopifnot(identical(unname(p2), unname(p))) #>             tim[\"orderqtl\", \"prep\"] <- timefun({ #>                 o <- seq_along(x) #>                 na.count <- ramorder(x, o, na.last = FALSE) #>             })[3L] #>             tim[\"orderqtl\", \"use\"] <- timefun({ #>                 p2 <- orderqtl(x, o, na.count, seq(0, 1, 0.25)) #>             })[3L] #>             stopifnot(identical(unname(p2), unname(p))) #>             sortordercache(x) #>             tim[\"sort.cache\", \"use\"] <- timefun({ #>                 p2 <- quantile(x, na.rm = TRUE) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x) #>             ordercache(x) #>             tim[\"order.cache\", \"use\"] <- timefun({ #>                 p2 <- quantile(x, na.rm = TRUE) #>             })[3L] #>             stopifnot(identical(p2, p)) #>             remcache(x) #>             if (plot) { #>                 barplot(t(tim), cex.names = 0.7) #>                 title(paste0(\"quantile(\", n, \")\")) #>             } #>             ret[[\"quantile\", as.character(n)]] <- tim #>         } #>     } #>     ret #> } #> <bytecode: 0x5587a93fc278> #> <environment: namespace:bit64>"},{"path":"https://bit64.r-lib.org/reference/sum.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary functions for integer64 vectors — sum.integer64","title":"Summary functions for integer64 vectors — sum.integer64","text":"Summary functions integer64 vectors. Function 'range' without arguments returns smallest largest value 'integer64' class.","code":""},{"path":"https://bit64.r-lib.org/reference/sum.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary functions for integer64 vectors — sum.integer64","text":"","code":"# S3 method for class 'integer64' any(..., na.rm = FALSE)  # S3 method for class 'integer64' all(..., na.rm = FALSE)  # S3 method for class 'integer64' sum(..., na.rm = FALSE)  # S3 method for class 'integer64' prod(..., na.rm = FALSE)  # S3 method for class 'integer64' min(..., na.rm = FALSE)  # S3 method for class 'integer64' max(..., na.rm = FALSE)  # S3 method for class 'integer64' range(..., na.rm = FALSE, finite = FALSE)  lim.integer64()"},{"path":"https://bit64.r-lib.org/reference/sum.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary functions for integer64 vectors — sum.integer64","text":"... atomic vectors class 'integer64' na.rm logical scalar indicating whether ignore NAs finite logical scalar indicating whether ignore NAs (just compatibility range.default())","code":""},{"path":"https://bit64.r-lib.org/reference/sum.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary functions for integer64 vectors — sum.integer64","text":"() () return logical scalar range() returns integer64 vector two elements min(), max(), sum() prod() return integer64 scalar","code":""},{"path":"https://bit64.r-lib.org/reference/sum.integer64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summary functions for integer64 vectors — sum.integer64","text":"numerical summary methods always return integer64. Therefore methods min,max range return +Inf,-Inf empty arguments, +9223372036854775807, -9223372036854775807 (sequence). true  NAs submitted argument na.rm=TRUE. lim.integer64 returns limits proper order -9223372036854775807, +9223372036854775807 without warning().","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/sum.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary functions for integer64 vectors — sum.integer64","text":"","code":"lim.integer64() #> integer64 #> [1] -9223372036854775807 9223372036854775807    range(as.integer64(1:12)) #> integer64 #> [1] 1  12"},{"path":"https://bit64.r-lib.org/reference/table.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross Tabulation and Table Creation for integer64 — table.integer64","title":"Cross Tabulation and Table Creation for integer64 — table.integer64","text":"table.integer64 uses cross-classifying integer64 vectors build contingency table counts combination vector values.","code":""},{"path":"https://bit64.r-lib.org/reference/table.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross Tabulation and Table Creation for integer64 — table.integer64","text":"","code":"table.integer64(   ...,   return = c(\"table\", \"data.frame\", \"list\"),   order = c(\"values\", \"counts\"),   nunique = NULL,   method = NULL,   dnn = list.names(...),   deparse.level = 1L )"},{"path":"https://bit64.r-lib.org/reference/table.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross Tabulation and Table Creation for integer64 — table.integer64","text":"... one objects can interpreted factors (including character strings), list (data frame) whose components can interpreted.  (.table .data.frame, arguments passed specific methods.) return choose return format, see details order default results created sorted \"values\", \"counts\" nunique NULL number unique values table (including NA). Providing nunique can speed-matching table cache. Note wrong nunique can cause undefined behaviour crash. method NULL automatic method selection suitable low-level method, see details dnn names given dimensions result (dimnames names). deparse.level controls default dnn constructed. See Details.","code":""},{"path":"https://bit64.r-lib.org/reference/table.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross Tabulation and Table Creation for integer64 — table.integer64","text":"default (return=\"table\") table() returns contingency table, object class \"table\", array integer values. Note unlike S result always array, 1D array one factor given. Note also multidimensional arrays dense return structure can dramatically increase RAM requirements (large arrays high mutual information, .e. many possible input combinations occur) table() limited 2^31 possible combinations (e.g. two input vectors 46340 unique values ). Finally note tabulated values value-combinations represented dimnames implied conversion values strings can cause severe performance problems since string needs integrated R's global string cache. can use return= options cope problems, potential combination limit increased 2^31 2^63 options, RAM required observed combinations string conversion avoided. return=\"data.frame\" get dense representation data.frame() (like resulting .data.frame(table(...))) observed combinations listed (data.frame row) corresponding frequency counts (latter component named responseName). inverse xtabs(). return=\"list\" also get dense representation simple list() components values integer64 vector technically tabulated values, 1D tabulated values , kD values representing potential combinations input values counts frequency counts dims kD: list vectors unique values input dimensions","code":""},{"path":"https://bit64.r-lib.org/reference/table.integer64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross Tabulation and Table Creation for integer64 — table.integer64","text":"function automatically chooses several low-level functions considering size x availability cache. Suitable methods hashmaptab (simultaneously creating using hashmap) hashtab (first creating hashmap using ) sortordertab (fast ordering) ordertab (memory saving ordering). argument dnn supplied, internal function list.names called compute 'dimname names'.  arguments ... named, names used.  remaining arguments, deparse.level = 0 gives empty name, deparse.level = 1 uses supplied argument symbol, deparse.level = 2 deparse argument. Arguments exclude, useNA, supported, .e. NAs always tabulated, , different table() sorted first order=\"values\".","code":""},{"path":"https://bit64.r-lib.org/reference/table.integer64.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Cross Tabulation and Table Creation for integer64 — table.integer64","text":"Note using .integer64.factor() can also input factors table.integer64 – levels() get lost.","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/table.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross Tabulation and Table Creation for integer64 — table.integer64","text":"","code":"message(\"pure integer64 examples\") #> pure integer64 examples x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE)) y <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE)) z <- sample(c(rep(NA, 9), letters), 32, TRUE) table.integer64(x) #> x #> <NA>    1    3    4    5    6    8    9  #>   18    1    5    2    2    1    1    2  table.integer64(x, order=\"counts\") #> x #>    8    6    1    9    5    4    3 <NA>  #>    1    1    1    2    2    2    5   18  table.integer64(x, y) #>       y #> x      <NA> 1 2 3 6 7 9 #>   <NA>    8 1 1 1 1 2 4 #>   1       0 0 1 0 0 0 0 #>   3       4 0 0 0 1 0 0 #>   4       2 0 0 0 0 0 0 #>   5       1 0 0 0 1 0 0 #>   6       0 0 1 0 0 0 0 #>   8       0 1 0 0 0 0 0 #>   9       0 0 0 0 0 1 1 table.integer64(x, y, return=\"data.frame\") #>       x    y Freq #> 1  <NA> <NA>    8 #> 2     3 <NA>    4 #> 3     4 <NA>    2 #> 4     5 <NA>    1 #> 5  <NA>    1    1 #> 6     8    1    1 #> 7  <NA>    2    1 #> 8     1    2    1 #> 9     6    2    1 #> 10 <NA>    3    1 #> 11 <NA>    6    1 #> 12    3    6    1 #> 13    5    6    1 #> 14 <NA>    7    2 #> 15    9    7    1 #> 16 <NA>    9    4 #> 17    9    9    1  message(\"via as.integer64.factor we can use 'table.integer64' also for factors\") #> via as.integer64.factor we can use 'table.integer64' also for factors table.integer64(x, as.integer64(as.factor(z))) #>        #> x      <NA> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #>   <NA>    2 2 0 0 2 1 1 1 0 1  2  1  1  0  2  1  1  0 #>   1       0 0 0 0 0 0 0 0 1 0  0  0  0  0  0  0  0  0 #>   3       1 1 1 0 0 0 0 0 0 0  1  0  1  0  0  0  0  0 #>   4       0 0 0 0 0 0 1 0 0 0  0  1  0  0  0  0  0  0 #>   5       0 0 0 0 0 0 0 0 0 0  1  0  0  1  0  0  0  0 #>   6       1 0 0 0 0 0 0 0 0 0  0  0  0  0  0  0  0  0 #>   8       0 0 0 1 0 0 0 0 0 0  0  0  0  0  0  0  0  0 #>   9       0 0 0 0 0 0 0 0 0 0  0  0  0  0  0  0  1  1"},{"path":"https://bit64.r-lib.org/reference/tiepos.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Positions of Tied Elements — tiepos","title":"Extract Positions of Tied Elements — tiepos","text":"tiepos returns positions elements participate ties.","code":""},{"path":"https://bit64.r-lib.org/reference/tiepos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Positions of Tied Elements — tiepos","text":"","code":"tiepos(x, ...)  # S3 method for class 'integer64' tiepos(x, nties = NULL, method = NULL, ...)"},{"path":"https://bit64.r-lib.org/reference/tiepos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Positions of Tied Elements — tiepos","text":"x vector data frame array NULL. ... ignored nties NULL number tied values (including NA). Providing nties can speed-x cache. Note wrong nties can cause undefined behaviour crash. method NULL automatic method selection suitable low-level method, see details","code":""},{"path":"https://bit64.r-lib.org/reference/tiepos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Positions of Tied Elements — tiepos","text":"integer vector positions","code":""},{"path":"https://bit64.r-lib.org/reference/tiepos.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Positions of Tied Elements — tiepos","text":"function automatically chooses several low-level functions considering size x availability cache. Suitable methods sortordertie (fast ordering) ordertie (memory saving ordering).","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/tiepos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Positions of Tied Elements — tiepos","text":"","code":"x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE)) tiepos(x) #>  [1]  1  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #> [24] 25 26 28 30 31 32  stopifnot(identical(tiepos(x),  (1:length(x))[duplicated(x) | rev(duplicated(rev(x)))]))"},{"path":"https://bit64.r-lib.org/reference/unipos.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Positions of Unique Elements — unipos","title":"Extract Positions of Unique Elements — unipos","text":"unipos returns positions elements returned unique().","code":""},{"path":"https://bit64.r-lib.org/reference/unipos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Positions of Unique Elements — unipos","text":"","code":"unipos(x, incomparables = FALSE, order = c(\"original\", \"values\", \"any\"), ...)  # S3 method for class 'integer64' unipos(   x,   incomparables = FALSE,   order = c(\"original\", \"values\", \"any\"),   nunique = NULL,   method = NULL,   ... )"},{"path":"https://bit64.r-lib.org/reference/unipos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Positions of Unique Elements — unipos","text":"x vector data frame array NULL. incomparables ignored order order positions unique values returned, see details ... ignored nunique NULL number unique values (including NA). Providing nunique can speed-x cache. Note wrong nunique can cause undefined behaviour crash. method NULL automatic method selection suitable low-level method, see details","code":""},{"path":"https://bit64.r-lib.org/reference/unipos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Positions of Unique Elements — unipos","text":"integer vector positions","code":""},{"path":"https://bit64.r-lib.org/reference/unipos.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Positions of Unique Elements — unipos","text":"function automatically chooses several low-level functions considering size x availability cache. Suitable methods hashmapupo (simultaneously creating using hashmap) hashupo (first creating hashmap using ) sortorderupo (fast ordering) orderupo (memory saving ordering). default order=\"original\" collects unique values order first appearance x like unique(), costs extra processing. order=\"values\" collects unique values sorted order like table(), costs extra processing hash methods comes free. order=\"\" collects unique values undefined order, possibly faster. hash methods quasi random order, sort methods sorted order.","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/unipos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Positions of Unique Elements — unipos","text":"","code":"x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE)) unipos(x) #> [1]  1  2  3  4  5  8 14 25 unipos(x, order=\"values\") #> [1]  3  5  4 14  2  1 25  8  stopifnot(identical(unipos(x),  (1:length(x))[!duplicated(x)])) stopifnot(identical(unipos(x),  match.integer64(unique(x), x))) stopifnot(identical(unipos(x, order=\"values\"),  match.integer64(unique(x, order=\"values\"), x))) stopifnot(identical(unique(x),  x[unipos(x)])) stopifnot(identical(unique(x, order=\"values\"),  x[unipos(x, order=\"values\")]))"},{"path":"https://bit64.r-lib.org/reference/unique.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Unique Elements from integer64 — unique.integer64","title":"Extract Unique Elements from integer64 — unique.integer64","text":"unique returns vector like x duplicate elements/rows removed.","code":""},{"path":"https://bit64.r-lib.org/reference/unique.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Unique Elements from integer64 — unique.integer64","text":"","code":"# S3 method for class 'integer64' unique(   x,   incomparables = FALSE,   order = c(\"original\", \"values\", \"any\"),   nunique = NULL,   method = NULL,   ... )"},{"path":"https://bit64.r-lib.org/reference/unique.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Unique Elements from integer64 — unique.integer64","text":"x vector data frame array NULL. incomparables ignored order order unique values returned, see details nunique NULL number unique values (including NA). Providing nunique can speed-matching x cache. Note wrong `nunique“ can cause undefined behaviour crash. method NULL automatic method selection suitable low-level method, see details ... ignored","code":""},{"path":"https://bit64.r-lib.org/reference/unique.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Unique Elements from integer64 — unique.integer64","text":"vector, object type x, one copy duplicated element.  attributes copied (result names).","code":""},{"path":"https://bit64.r-lib.org/reference/unique.integer64.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Unique Elements from integer64 — unique.integer64","text":"function automatically chooses several low-level functions considering size x availability cache. Suitable methods hashmapuni (simultaneously creating using hashmap) hashuni (first creating hashmap using ) sortuni (fast sorting sorted order ) sortorderuni (fast ordering original order ) orderuni (memory saving ordering). default order=\"original\" returns unique values order first appearance x like unique(), costs extra processing. order=\"values\" returns unique values sorted order like table(), costs extra processing hash methods comes free. order=\"\" returns unique values undefined order, possibly faster. hash methods quasi random order, sort methods sorted order.","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/unique.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Unique Elements from integer64 — unique.integer64","text":"","code":"x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE)) unique(x) #> integer64 #> [1] <NA> 7    9    4    5    1    8    unique(x, order=\"values\") #> integer64 #> [1] <NA> 1    4    5    7    8    9     stopifnot(identical(unique(x),  x[!duplicated(x)])) stopifnot(identical(unique(x),  as.integer64(unique(as.integer(x))))) stopifnot(identical(unique(x, order=\"values\") ,  as.integer64(sort(unique(as.integer(x)), na.last=FALSE))))"},{"path":"https://bit64.r-lib.org/reference/xor.integer64.html","id":null,"dir":"Reference","previous_headings":"","what":"Binary operators for integer64 vectors — xor.integer64","title":"Binary operators for integer64 vectors — xor.integer64","text":"Binary operators integer64 vectors.","code":""},{"path":"https://bit64.r-lib.org/reference/xor.integer64.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binary operators for integer64 vectors — xor.integer64","text":"","code":"binattr(e1, e2)  # S3 method for class 'integer64' e1 + e2  # S3 method for class 'integer64' e1 - e2  # S3 method for class 'integer64' e1%/%e2  # S3 method for class 'integer64' e1%%e2  # S3 method for class 'integer64' e1 * e2  # S3 method for class 'integer64' e1^e2  # S3 method for class 'integer64' e1/e2  # S3 method for class 'integer64' e1 == e2  # S3 method for class 'integer64' e1 != e2  # S3 method for class 'integer64' e1 < e2  # S3 method for class 'integer64' e1 <= e2  # S3 method for class 'integer64' e1 > e2  # S3 method for class 'integer64' e1 >= e2  # S3 method for class 'integer64' e1 & e2  # S3 method for class 'integer64' e1 | e2  # S3 method for class 'integer64' xor(x, y)"},{"path":"https://bit64.r-lib.org/reference/xor.integer64.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binary operators for integer64 vectors — xor.integer64","text":"e1 atomic vector class 'integer64' e2 atomic vector class 'integer64' x atomic vector class 'integer64' y atomic vector class 'integer64'","code":""},{"path":"https://bit64.r-lib.org/reference/xor.integer64.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binary operators for integer64 vectors — xor.integer64","text":"&, |, xor(), !=, ==, <, <=, >, >= return logical vector ^ / return double vector +, -, *, %/%, %% return vector class 'integer64'","code":""},{"path":[]},{"path":"https://bit64.r-lib.org/reference/xor.integer64.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Binary operators for integer64 vectors — xor.integer64","text":"","code":"as.integer64(1:12) - 1 #> integer64 #>  [1] 0  1  2  3  4  5  6  7  8  9  10 11   options(integer64_semantics=\"new\")   d <- 2.5   i <- as.integer64(5)   d/i  # new 0.5 #> [1] 0.5   d*i  # new 13 #> integer64 #> [1] 13   i*d  # new 13 #> integer64 #> [1] 13   options(integer64_semantics=\"old\")   d/i  # old: 0.4 #> [1] 0.4   d*i  # old: 10 #> integer64 #> [1] 10   i*d  # old: 13 #> integer64 #> [1] 13"},{"path":[]},{"path":"https://bit64.r-lib.org/news/index.html","id":"notes-4-7-99","dir":"Changelog","previous_headings":"","what":"NOTES","title":"bit64 4.7.99 (in development)","text":"{bit64} longer prints start-messages .onAttach() hook (#106). Thanks @hadley request.","code":""},{"path":"https://bit64.r-lib.org/news/index.html","id":"bit64-460-1-2025-01-16","dir":"Changelog","previous_headings":"","what":"bit64 4.6.0-1 (2025-01-16)","title":"bit64 4.6.0-1 (2025-01-16)","text":"CRAN release: 2025-01-16","code":""},{"path":"https://bit64.r-lib.org/news/index.html","id":"notice-of-planned-breaking-changes-4-6-0-1","dir":"Changelog","previous_headings":"","what":"NOTICE OF PLANNED BREAKING CHANGES","title":"bit64 4.6.0-1 (2025-01-16)","text":"{bit64} exports many S3 methods directly. Calling S3 methods directly generally bad form; rely S3 dispatch system . Needing export S3 method usually indicative deep issue ’s otherwise hard work around. plan un-export S3 methods future versions. release, change behavior besides notice NEWS. Going forward, see two types S3 exports: (1) exports discoverable direct usage (, global GitHub search, includes CRAN mirror, turned R code calling directly, except perhaps ::: form, unaffected un-export); (2) exports observed called directly number downstreams. former, comfortable un-exporting aggressively; latter, take gradual approach. S3 methods currently exported, found record called directly: -.integer64, :.default, :.integer64, !.integer64, !=.integer64, [.integer64, [[.integer64, [[<-.integer64, *.integer64, /.integer64, &.integer64, %/%.integer64, %%.integer64, %%.default, %%.integer64, ^.integer64, +.integer64, <.integer64, <=.integer64, ==.integer64, >.integer64, >=.integer64, |.integer64, .equal.integer64, .bitstring.integer64, .integer64.factor, .integer64.integer64, .integer64.NULL, .list.integer64, .logical.integer64, cbind.integer64, ceiling.integer64, cummax.integer64, cummin.integer64, cumprod.integer64, cumsum.integer64, diff.integer64, duplicated.integer64, floor.integer64, hashdup.cache_integer64, hashfin.cache_integer64, hashfun.integer64, hashmap.integer64, hashmaptab.integer64, hashmapuni.integer64, hashmapupo.integer64, hashpos.cache_integer64, hashrev.cache_integer64, hashrin.cache_integer64, hashtab.cache_integer64, hashuni.cache_integer64, hashupo.cache_integer64, .double.default, .double.integer64, .finite.integer64, .infinite.integer64, .nan.integer64, .sorted.integer64, .vector.integer64, keypos.integer64, length<-.integer64, log10.integer64, log2.integer64, match.default, match.integer64, mean.integer64, median.integer64, mergeorder.integer64, mergesort.integer64, mergesortorder.integer64, na.count.integer64, nties.integer64, nunique.integer64, nvalid.integer64, order.default, order.integer64, orderdup.integer64, orderfin.integer64, orderkey.integer64, ordernut.integer64, orderpos.integer64, orderqtl.integer64, orderrnk.integer64, ordertab.integer64, ordertie.integer64, orderuni.integer64, orderupo.integer64, prank.integer64, print.bitstring, prod.integer64, qtile.integer64, quantile.integer64, quickorder.integer64, quicksort.integer64, quicksortorder.integer64, radixorder.integer64, radixsort.integer64, radixsortorder.integer64, ramorder.integer64, ramsort.integer64, ramsortorder.integer64, range.integer64, rank.default, rbind.integer64, round.integer64, scale.integer64, shellorder.integer64, shellsort.integer64, shellsortorder.integer64, sign.integer64, signif.integer64, sort.integer64, sortfin.integer64, sortnut.integer64, sortorderdup.integer64, sortorderkey.integer64, sortorderpos.integer64, sortorderrnk.integer64, sortordertab.integer64, sortordertie.integer64, sortorderuni.integer64, sortorderupo.integer64, sortql.integer64, sorttab.integer64, sortuni.integer64, sqrt.integer64, summary.integer64, table.integer64, tiepos.integer64, trunc.integer64, unipos.integer64 S3 methods currently exported find record called directly: abs.integer64, .character.integer64, .data.frame.integer64, .double.integer64, .integer.integer64, .integer64.bitstring, .integer64.character, .integer64.double, .integer64.integer, .integer64.logical, c.integer64, format.integer64, identical.integer64, .na.integer64, lim.integer64, max.integer64, min.integer64, print.integer64, rank.integer64, seq.integer64, str.integer64, sum.integer64, unique.integer64 next release (provisionally, 4.7.0), add warning() S3 method former classification, nothing change latter classification. may reach authors observed call methods directly. subsequent release (provisionally, 4.8.0), un-export S3 method former classification, add warning() S3 method latter classification. sub-subsequent release (provisionally, 4.9.0), un-export S3 method latter classification. Please reach (e.g., GitHub log #76) concerns plan. {bit64} lists {bit} Depends:. IMO form dependency deprecated R now Imports: widely available well-supported many years. next release (provisionally, 4.7.0), move bit Imports. practical implication currently, library(bit64) make {bit} objects like .bit() available use without namespace-qualification. practice makes code harder read maintain. Users relying scripts can (1) write library(bit) attach {bit} explicitly (2) namespace-qualify {bit} calls bit::. Package authors relying can (1) add import(bit) make full {bit} namespace available (2) namespace-qualify {bit} calls bit::; adding {bit} Imports: Suggests: also necessary. reach CRAN authors required changes. Depending impact size, might make transition gradual (e.g. starting re-exporting {bit} functions {bit64}, warning, un-exporting subsequent release).","code":""},{"path":"https://bit64.r-lib.org/news/index.html","id":"new-features-4-6-0-1","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"bit64 4.6.0-1 (2025-01-16)","text":"Implemented S3 methods rowSums() colSums(). Importantly handle NA values correctly, #38. Thanks @vlulla request. Note implemented wrappers apply() calls, may efficient. PRs welcome implementing efficient equivalents. Note necessity, grows set base exports overwritten include rowSums() colSums(), exported S3 generics dispatching base::rowSums() base::colSums() default. Partially powering new aperm() method integer64 allows apply() work intended. Using apply() directly may still strip integer64 class; may supported later (see #87). .na() supported long vector input (2^31 elements), #30. Thanks @ilia-kats request. Long vector support added -needed basis don’t great machine testing features – PRs welcome!","code":""},{"path":"https://bit64.r-lib.org/news/index.html","id":"bug-fixes-4-6-0-1","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"bit64 4.6.0-1 (2025-01-16)","text":".equal.integer64() gets fix vector scale= work intended .equal.numeric() got R 4.1.3, #23. Made edits match() handle .integer64(table) better older versions R, including new mtfrm() method integer64 objects R>=4.2.0, #85 #111.","code":""},{"path":"https://bit64.r-lib.org/news/index.html","id":"notes-4-6-0-1","dir":"Changelog","previous_headings":"","what":"NOTES","title":"bit64 4.6.0-1 (2025-01-16)","text":"creating, developing, maintaining {bit64} 13 years, Jens Oehlschlägel decided step maintainer package. Michael Chirico take duty. Thank Jens creating wonderful & important part R ecosystem! don’t major plans new features, mostly hope keep package running date. Contributors welcome! also trying freshen code base make contribution easier. R version dependency increased 3.0.1 (May 2013) 3.4.0 (April 2017). plan keep roughly R dependency {data.table}, .e., old possibly long possible, bias towards gradually bringing new R features reduce maintenance overhead growing nest workarounds keep package “fresh” users latest R versions. Required package {bit} already requires R 3.4.0, old 3.0.1 requirement effectively impossible anyway. Default packages {methods}, {stats}, {utils} now Imports:, Depends:, dependencies. Depends: -dated mode dependency R. affect small audience users run R R_DEFAULT_PACKAGES=NULL (subset excluding three), relying (perhaps implicitly) {bit64} responsible attaching packages. intention move {bit} Depends: Imports: well, migration done gingerly – conceivable constitute breaking change use cases, therefore done phases. Nothing done release, earliest warning next release, warning rely {bit64} attach {bit} functions . Package documentation now managed {roxygen2}, #61. tried retain everything original documentation, diff required quite unmanageable (5,000+ lines), please alert anything looks amiss. importantly, ensured NAMESPACE remains unchanged. signature identical.integer64() loses extptr..ref=, unavailable R<4.2.0, gains ... allow argument newer versions, #37. retains transparency arguments named signature (thus ?identical.integer64 well available tab-completion) also retaining old R version dependency R 3.3.0.","code":""}]
