<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Searching and other uses of sorting for 64bit integers — sortnut • bit64</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Source_Sans_Pro-0.4.9/font.css" rel="stylesheet"><link href="../deps/Source_Code_Pro-0.4.9/font.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Searching and other uses of sorting for 64bit integers — sortnut"><meta name="description" content="This is roughly an implementation of hash functionality but based on sorting
instead on a hashmap. Since sorting is more informative than hashing we
can do some more interesting things."><meta property="og:description" content="This is roughly an implementation of hash functionality but based on sorting
instead on a hashmap. Since sorting is more informative than hashing we
can do some more interesting things."><script defer data-domain="bit64.r-lib.org,all.tidyverse.org" src="https://plausible.io/js/plausible.js"></script></head><body>
    <a href="#container" class="visually-hidden-focusable">Skip to content</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-none" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">bit64</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="Released version">4.7.99</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/r-lib/bit64/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic" id="container">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Searching and other uses of sorting for 64bit integers</h1>
      <small class="dont-index">Source: <a href="https://github.com/r-lib/bit64/blob/main/R/sortuse64.R" class="external-link"><code>R/sortuse64.R</code></a></small>
      <div class="d-none name"><code>sortnut.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>This is roughly an implementation of hash functionality but based on sorting
instead on a hashmap. Since sorting is more informative than hashing we
can do some more interesting things.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">sortnut</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">sortnut</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">ordernut</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">ordernut</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">sortfin</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">x</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">sortfin</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">x</span>, method <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">orderfin</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">x</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">orderfin</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">x</span>, method <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">orderpos</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">x</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">orderpos</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">x</span>, nomatch <span class="op">=</span> <span class="cn">NA</span>, method <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">sortorderpos</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, <span class="va">x</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">sortorderpos</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, <span class="va">x</span>, nomatch <span class="op">=</span> <span class="cn">NA</span>, method <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">orderdup</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">orderdup</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, method <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">sortorderdup</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">sortorderdup</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, method <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">sortuni</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">nunique</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">sortuni</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">nunique</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">orderuni</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">nunique</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">orderuni</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">nunique</span>, keep.order <span class="op">=</span> <span class="cn">FALSE</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">sortorderuni</span><span class="op">(</span><span class="va">table</span>, <span class="va">sorted</span>, <span class="va">order</span>, <span class="va">nunique</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">sortorderuni</span><span class="op">(</span><span class="va">table</span>, <span class="va">sorted</span>, <span class="va">order</span>, <span class="va">nunique</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">orderupo</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">nunique</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">orderupo</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">nunique</span>, keep.order <span class="op">=</span> <span class="cn">FALSE</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">sortorderupo</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, <span class="va">nunique</span>, keep.order <span class="op">=</span> <span class="cn">FALSE</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">sortorderupo</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, <span class="va">nunique</span>, keep.order <span class="op">=</span> <span class="cn">FALSE</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">ordertie</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">nties</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">ordertie</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">nties</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">sortordertie</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, <span class="va">nties</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">sortordertie</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, <span class="va">nties</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">sorttab</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">nunique</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">sorttab</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">nunique</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">ordertab</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">nunique</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">ordertab</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">nunique</span>, denormalize <span class="op">=</span> <span class="cn">FALSE</span>, keep.order <span class="op">=</span> <span class="cn">FALSE</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">sortordertab</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">sortordertab</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, denormalize <span class="op">=</span> <span class="cn">FALSE</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">orderkey</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, na.skip.num <span class="op">=</span> <span class="fl">0L</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">orderkey</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, na.skip.num <span class="op">=</span> <span class="fl">0L</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">sortorderkey</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, na.skip.num <span class="op">=</span> <span class="fl">0L</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">sortorderkey</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, na.skip.num <span class="op">=</span> <span class="fl">0L</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">orderrnk</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">na.count</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">orderrnk</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">na.count</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">sortorderrnk</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, <span class="va">na.count</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">sortorderrnk</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">order</span>, <span class="va">na.count</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">sortqtl</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">na.count</span>, <span class="va">probs</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">sortqtl</span><span class="op">(</span><span class="va">sorted</span>, <span class="va">na.count</span>, <span class="va">probs</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="fu">orderqtl</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">na.count</span>, <span class="va">probs</span>, <span class="va">...</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'integer64'</span></span>
<span><span class="fu">orderqtl</span><span class="op">(</span><span class="va">table</span>, <span class="va">order</span>, <span class="va">na.count</span>, <span class="va">probs</span>, <span class="va">...</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-sorted">sorted<a class="anchor" aria-label="anchor" href="#arg-sorted"></a></dt>
<dd><p>a sorted <code><a href="bit64-package.html">integer64</a></code> vector</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>further arguments, passed from generics, ignored in methods</p></dd>


<dt id="arg-table">table<a class="anchor" aria-label="anchor" href="#arg-table"></a></dt>
<dd><p>the original data with original order under the sorted vector</p></dd>


<dt id="arg-order">order<a class="anchor" aria-label="anchor" href="#arg-order"></a></dt>
<dd><p>an <code><a href="https://rdrr.io/r/base/integer.html" class="external-link">integer</a></code> order vector that turns 'table' into 'sorted'</p></dd>


<dt id="arg-x">x<a class="anchor" aria-label="anchor" href="#arg-x"></a></dt>
<dd><p>an <code><a href="bit64-package.html">integer64</a></code> vector</p></dd>


<dt id="arg-method">method<a class="anchor" aria-label="anchor" href="#arg-method"></a></dt>
<dd><p>see Details</p></dd>


<dt id="arg-nomatch">nomatch<a class="anchor" aria-label="anchor" href="#arg-nomatch"></a></dt>
<dd><p>the value to be returned if an element is not found in the hashmap</p></dd>


<dt id="arg-nunique">nunique<a class="anchor" aria-label="anchor" href="#arg-nunique"></a></dt>
<dd><p>number of unique elements, usually we get this from cache
or call <code>sortnut</code> or <code>ordernut</code></p></dd>


<dt id="arg-keep-order">keep.order<a class="anchor" aria-label="anchor" href="#arg-keep-order"></a></dt>
<dd><p>determines order of results and speed: <code>FALSE</code> (the default)
is faster and returns in sorted order, <code>TRUE</code> returns in the order of first
appearance in the original data, but this requires extra work</p></dd>


<dt id="arg-nties">nties<a class="anchor" aria-label="anchor" href="#arg-nties"></a></dt>
<dd><p>number of tied values, usually we get this from cache or
call <code>sortnut</code> or <code>ordernut</code></p></dd>


<dt id="arg-denormalize">denormalize<a class="anchor" aria-label="anchor" href="#arg-denormalize"></a></dt>
<dd><p>FALSE returns counts of unique values, TRUE returns each
value with its counts</p></dd>


<dt id="arg-na-skip-num">na.skip.num<a class="anchor" aria-label="anchor" href="#arg-na-skip-num"></a></dt>
<dd><p>0 or the number of <code>NA</code>s. With 0, <code>NA</code>s are coded with 1L,
with the number of <code>NA</code>s, these are coded with <code>NA</code></p></dd>


<dt id="arg-na-count">na.count<a class="anchor" aria-label="anchor" href="#arg-na-count"></a></dt>
<dd><p>the number of <code>NA</code>s, needed for this low-level function algorithm</p></dd>


<dt id="arg-probs">probs<a class="anchor" aria-label="anchor" href="#arg-probs"></a></dt>
<dd><p>vector of probabilities in <code>[0..1]</code> for which we seek quantiles</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>see details</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>

<table class="table table"><tr><td><strong>sortfun</strong></td><td><strong>orderfun</strong></td><td><strong>sortorderfun</strong></td><td><strong>see also</strong></td><td><strong>description</strong></td></tr><tr><td><code>sortnut</code></td><td><code>ordernut</code></td><td></td><td></td><td>return number of tied and of unique values</td></tr><tr><td><code>sortfin</code></td><td><code>orderfin</code></td><td></td><td><code><a href="match.integer64.html">%in%.integer64</a></code></td><td>return logical whether <code>x</code> is in <code>table</code></td></tr><tr><td></td><td><code>orderpos</code></td><td><code>sortorderpos</code></td><td><code><a href="match.integer64.html">match()</a></code></td><td>return positions of <code>x</code> in <code>table</code></td></tr><tr><td></td><td><code>orderdup</code></td><td><code>sortorderdup</code></td><td><code><a href="duplicated.integer64.html">duplicated()</a></code></td><td>return logical whether values are duplicated</td></tr><tr><td><code>sortuni</code></td><td><code>orderuni</code></td><td><code>sortorderuni</code></td><td><code><a href="unique.integer64.html">unique()</a></code></td><td>return unique values (=dimensiontable)</td></tr><tr><td></td><td><code>orderupo</code></td><td><code>sortorderupo</code></td><td><code><a href="unique.integer64.html">unique()</a></code></td><td>return positions of unique values</td></tr><tr><td></td><td><code>ordertie</code></td><td><code>sortordertie</code></td><td></td><td>return positions of tied values</td></tr><tr><td></td><td><code>orderkey</code></td><td><code>sortorderkey</code></td><td></td><td>positions of values in vector of unique values (match in dimensiontable)</td></tr><tr><td><code>sorttab</code></td><td><code>ordertab</code></td><td><code>sortordertab</code></td><td><code><a href="table.integer64.html">table()</a></code></td><td>tabulate frequency of values</td></tr><tr><td></td><td><code>orderrnk</code></td><td><code>sortorderrnk</code></td><td></td><td>rank averaging ties</td></tr><tr><td><code>sortqtl</code></td><td><code>orderqtl</code></td><td></td><td></td><td>return quantiles given probabilities</td></tr></table><p>The functions <code>sortfin</code>, <code>orderfin</code>, <code>orderpos</code> and <code>sortorderpos</code> each
offer three algorithms for finding <code>x</code> in <code>table</code>.</p>
<p>With <code>method=1L</code> each value of <code>x</code> is searched independently using
<em>binary search</em>, this is fastest for small <code>table</code>s.</p>
<p>With <code>method=2L</code> the values of <code>x</code> are first sorted and then searched using
<em>doubly exponential search</em>, this is the best allround method.</p>
<p>With <code>method=3L</code> the values of <code>x</code> are first sorted and then searched using
simple merging, this is the fastest method if <code>table</code> is huge and <code>x</code> has
similar size and distribution of values.</p>
<p>With <code>method=NULL</code> the functions use a heuristic to determine the fastest
algorithm.</p>
<p>The functions <code>orderdup</code> and <code>sortorderdup</code> each offer two algorithms for
setting the truth values in the return vector.</p>
<p>With <code>method=1L</code> the return values are set directly which causes random
write access on a possibly large return vector.</p>
<p>With <code>method=2L</code> the return values are first set in a smaller bit-vector –
random access limited to a smaller memory region – and finally written
sequentially to the logical output  vector.</p>
<p>With <code>method=NULL</code> the functions use a heuristic to determine the fastest
algorithm.</p>
    </div>
    <div class="section level2">
    <h2 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a></h2>
    <div class="dont-index"><p><code><a href="match.integer64.html">match()</a></code></p></div>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span> <span class="fu"><a href="https://rdrr.io/r/base/message.html" class="external-link">message</a></span><span class="op">(</span><span class="st">"check the code of 'optimizer64' for examples:"</span><span class="op">)</span></span></span>
<span class="r-msg co"><span class="r-pr">#&gt;</span> check the code of 'optimizer64' for examples:</span>
<span class="r-in"><span> <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">optimizer64</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> function (nsmall = 2L^16L, nbig = 2L^25L, timefun = repeat.time, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     what = c("match", "%in%", "duplicated", "unique", "unipos", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         "table", "rank", "quantile"), uniorder = c("original", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         "values", "any"), taborder = c("values", "counts"), plot = TRUE) </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     uniorder &lt;- match.arg(uniorder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     taborder &lt;- match.arg(taborder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ret &lt;- vector("list", 2L * length(what))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     dim(ret) &lt;- c(length(what), 2L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     dimnames(ret) &lt;- list(what, c(nsmall, nbig))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if (plot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         oldpar &lt;- par(no.readonly = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         on.exit(par(oldpar))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         par(mfrow = c(2L, 1L))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if ("match" %in% what) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         message("match: timings of different methods")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         N1 &lt;- c(nsmall, nbig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         N2 &lt;- c(nbig, nsmall)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (i in seq_along(N1)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             n1 &lt;- N1[i]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             n2 &lt;- N2[i]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x1 &lt;- c(sample(n2, n1 - 1L, TRUE), NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x2 &lt;- c(sample(n2, n2 - 1L, TRUE), NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim &lt;- matrix(0, 9L, 3L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             dimnames(tim) &lt;- list(c("match", "match.64", "hashpos", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "hashrev", "sortorderpos", "orderpos", "hashcache", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "sortorder.cache", "order.cache"), c("prep", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "both", "use"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["match", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p &lt;- match(x1, x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x1 &lt;- as.integer64(x1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x2 &lt;- as.integer64(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["match.64", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- match.integer64(x1, x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashpos", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 h2 &lt;- hashmap(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashpos", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- hashpos(h2, x1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashrev", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 h1 &lt;- hashmap(x1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashrev", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p1 &lt;- hashrev(h1, x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p1, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderpos", "prep"] &lt;- system.time({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 s2 &lt;- clone(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o2 &lt;- seq_along(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramsortorder(s2, o2, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderpos", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- sortorderpos(s2, o2, x1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderpos", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o2 &lt;- seq_along(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramorder(x2, o2, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderpos", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- orderpos(x2, o2, x1, method = 2L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             hashcache(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashcache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- match.integer64(x1, x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             sortordercache(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorder.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- match.integer64(x1, x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ordercache(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["order.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- match.integer64(x1, x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (plot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 barplot(t(tim))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 n &lt;- format(c(n1, n2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 title(paste("match", n[1L], "in", n[2L]))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ret[["match", as.character(n1)]] &lt;- tim</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if ("%in%" %in% what) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         message("%in%: timings of different methods")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         N1 &lt;- c(nsmall, nbig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         N2 &lt;- c(nbig, nsmall)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (i in seq_along(N1)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             n1 &lt;- N1[i]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             n2 &lt;- N2[i]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x1 &lt;- c(sample(n2, n1 - 1L, TRUE), NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x2 &lt;- c(sample(n2, n2 - 1L, TRUE), NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim &lt;- matrix(0, 10L, 3L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             dimnames(tim) &lt;- list(c("%in%", "match.64", "%in%.64", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "hashfin", "hashrin", "sortfin", "orderfin", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "hash.cache", "sortorder.cache", "order.cache"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 c("prep", "both", "use"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["%in%", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p &lt;- x1 %in% x2</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x1 &lt;- as.integer64(x1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x2 &lt;- as.integer64(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["match.64", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- match.integer64(x1, x2, nomatch = 0L) &gt; </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   0L</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["%in%.64", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- `%in%.integer64`(x1, x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashfin", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 h2 &lt;- hashmap(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashfin", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- hashfin(h2, x1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashrin", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 h1 &lt;- hashmap(x1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashrin", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p1 &lt;- hashrin(h1, x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortfin", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 s2 &lt;- clone(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramsort(s2, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortfin", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- sortfin(s2, x1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderfin", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o2 &lt;- seq_along(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramorder(x2, o2, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderfin", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- orderfin(x2, o2, x1)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             hashcache(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hash.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- `%in%.integer64`(x1, x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             sortordercache(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorder.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- `%in%.integer64`(x1, x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ordercache(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["order.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- `%in%.integer64`(x1, x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (plot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 barplot(t(tim))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 n &lt;- format(c(n1, n2))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 title(paste(n[1L], "%in%", n[2L]))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ret[["%in%", as.character(n1)]] &lt;- tim</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if ("duplicated" %in% what) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         message("duplicated: timings of different methods")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         N &lt;- c(nsmall, nbig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (i in seq_along(N)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             n &lt;- N[i]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x &lt;- c(sample(n, n - 1L, TRUE), NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim &lt;- matrix(0, 10L, 3L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             dimnames(tim) &lt;- list(c("duplicated", "duplicated.64", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "hashdup", "sortorderdup1", "sortorderdup2", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "orderdup1", "orderdup2", "hash.cache", "sortorder.cache", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "order.cache"), c("prep", "both", "use"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["duplicated", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p &lt;- duplicated(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x &lt;- as.integer64(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["duplicated.64", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- duplicated(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashdup", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 h &lt;- hashmap(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashdup", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- hashdup(h)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderdup1", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 s &lt;- clone(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o &lt;- seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramsortorder(s, o, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nunique &lt;- sortnut(s)[1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderdup1", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- sortorderdup(s, o, method = 1L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderdup2", "prep"] &lt;- tim["sortorderdup1", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "prep"]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderdup2", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- sortorderdup(s, o, method = 2L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderdup1", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o &lt;- seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramorder(x, o, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nunique &lt;- ordernut(x, o)[1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderdup1", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- orderdup(x, o, method = 1L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderdup2", "prep"] &lt;- tim["orderdup1", "prep"]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderdup2", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- orderdup(x, o, method = 2L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             hashcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hash.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- duplicated(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             sortordercache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorder.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- duplicated(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ordercache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["order.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- duplicated(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (plot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 barplot(t(tim), cex.names = 0.7)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 title(paste0("duplicated(", n, ")"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ret[["duplicated", as.character(n)]] &lt;- tim</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if ("unique" %in% what) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         message("unique: timings of different methods")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         N &lt;- c(nsmall, nbig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (i in seq_along(N)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             n &lt;- N[i]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x &lt;- c(sample(n, n - 1L, TRUE), NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim &lt;- matrix(0, 15L, 3L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             dimnames(tim) &lt;- list(c("unique", "unique.64", "hashmapuni", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "hashuni", "hashunikeep", "sortuni", "sortunikeep", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "orderuni", "orderunikeep", "hashdup", "sortorderdup", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "hash.cache", "sort.cache", "sortorder.cache", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "order.cache"), c("prep", "both", "use"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["unique", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p &lt;- unique(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x &lt;- as.integer64(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             p &lt;- as.integer64(p)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "values") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramsort(p, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["unique.64", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- unique(x, order = uniorder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder != "any") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashmapuni", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- hashmapuni(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "original") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashuni", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 h &lt;- hashmap(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashuni", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- hashuni(h)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "values") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(sort(p2, na.last = FALSE), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashunikeep", "prep"] &lt;- tim["hashuni", "prep"]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashunikeep", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- hashuni(h, keep.order = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "original") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortuni", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 s &lt;- clone(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramsort(s, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nunique &lt;- sortnut(s)[1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortuni", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- sortuni(s, nunique)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "values") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(sort(p2, na.last = FALSE), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortunikeep", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 s &lt;- clone(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o &lt;- seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramsortorder(s, o, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nunique &lt;- sortnut(s)[1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortunikeep", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- sortorderuni(x, s, o, nunique)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "original") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderuni", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o &lt;- seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramorder(x, o, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nunique &lt;- ordernut(x, o)[1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderuni", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- orderuni(x, o, nunique)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "values") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(sort(p2, na.last = FALSE), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderunikeep", "prep"] &lt;- tim["orderuni", "prep"]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderunikeep", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- orderuni(x, o, nunique, keep.order = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nunique &lt;- ordernut(x, o)[1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "original") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashdup", "prep"] &lt;- tim["hashuni", "prep"]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashdup", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- x[!hashdup(h)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "original") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderdup", "prep"] &lt;- tim["sortunikeep", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "prep"]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderdup", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- x[!sortorderdup(s, o)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "original") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             hashcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hash.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- unique(x, order = uniorder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder != "any") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             sortcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sort.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- unique(x, order = uniorder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder != "any") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             sortordercache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorder.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- unique(x, order = uniorder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder != "any") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ordercache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["order.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- unique(x, order = uniorder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder != "any") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical.integer64(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (plot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 barplot(t(tim), cex.names = 0.7)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 title(paste0("unique(", n, ", order=", uniorder, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   ")"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ret[["unique", as.character(n)]] &lt;- tim</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if ("unipos" %in% what) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         message("unipos: timings of different methods")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         N &lt;- c(nsmall, nbig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (i in seq_along(N)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             n &lt;- N[i]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x &lt;- c(sample(n, n - 1L, TRUE), NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim &lt;- matrix(0, 14L, 3L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             dimnames(tim) &lt;- list(c("unique", "unipos.64", "hashmapupo", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "hashupo", "hashupokeep", "sortorderupo", "sortorderupokeep", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "orderupo", "orderupokeep", "hashdup", "sortorderdup", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "hash.cache", "sortorder.cache", "order.cache"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 c("prep", "both", "use"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["unique", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 unique(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x &lt;- as.integer64(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["unipos.64", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p &lt;- unipos(x, order = uniorder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashmapupo", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- hashmapupo(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "original") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashupo", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 h &lt;- hashmap(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashupo", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- hashupo(h)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "values") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical(sort(p2, na.last = FALSE), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   sort(p, na.last = FALSE)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashupokeep", "prep"] &lt;- tim["hashupo", "prep"]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashupokeep", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- hashupo(h, keep.order = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "original") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderupo", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 s &lt;- clone(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o &lt;- seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramsortorder(s, o, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nunique &lt;- sortnut(s)[1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderupo", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- sortorderupo(s, o, nunique)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "values") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderupokeep", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 s &lt;- clone(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o &lt;- seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramsortorder(s, o, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nunique &lt;- sortnut(s)[1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderupokeep", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- sortorderupo(s, o, nunique, keep.order = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "original") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderupo", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o &lt;- seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramorder(x, o, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nunique &lt;- ordernut(x, o)[1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderupo", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- orderupo(x, o, nunique)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "values") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderupokeep", "prep"] &lt;- tim["orderupo", "prep"]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderupokeep", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- orderupo(x, o, nunique, keep.order = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nunique &lt;- ordernut(x, o)[1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "original") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashdup", "prep"] &lt;- tim["hashupo", "prep"]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashdup", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- (1:n)[!hashdup(h)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "original") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderdup", "prep"] &lt;- tim["sortorderupokeep", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "prep"]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderdup", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- (1:n)[!sortorderdup(s, o)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder == "original") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             hashcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hash.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- unipos(x, order = uniorder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder != "any") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             sortordercache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorder.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- unipos(x, order = uniorder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder != "any") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ordercache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["order.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- unipos(x, order = uniorder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (uniorder != "any") </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (plot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 barplot(t(tim), cex.names = 0.7)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 title(paste0("unipos(", n, ", order=", uniorder, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   ")"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ret[["unipos", as.character(n)]] &lt;- tim</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if ("table" %in% what) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         message("table: timings of different methods")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         N &lt;- c(nsmall, nbig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (i in seq_along(N)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             n &lt;- N[i]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x &lt;- c(sample.int(1024L, n - 1L, replace = TRUE), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim &lt;- matrix(0, 13L, 3L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             dimnames(tim) &lt;- list(c("tabulate", "table", "table.64", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "hashmaptab", "hashtab", "hashtab2", "sorttab", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "sortordertab", "ordertab", "ordertabkeep", "hash.cache", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "sort.cache", "order.cache"), c("prep", "both", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "use"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["tabulate", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 tabulate(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["table", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p &lt;- table(x, exclude = NULL)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             p &lt;- p[-length(p)]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x &lt;- as.integer64(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["table.64", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- table.integer64(x, order = taborder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             p2 &lt;- p2[-1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashmaptab", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p &lt;- hashmaptab(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashtab", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 h &lt;- hashmap(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashtab", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- hashtab(h)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashtab2", "prep"] &lt;- tim["hashtab", "prep"] + </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   h &lt;- hashmap(x, nunique = h$nunique)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hashtab2", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- hashtab(h)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             sortp &lt;- function(p) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 s &lt;- p$values</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o &lt;- seq_along(s)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramsortorder(s, o, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 list(values = s, counts = p$counts[o])</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             p &lt;- sortp(p)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             p2 &lt;- sortp(p2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sorttab", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 s &lt;- clone(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramsort(s, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nunique &lt;- sortnut(s)[1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sorttab", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- list(values = sortuni(s, nunique), counts = sorttab(s, </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   nunique))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortordertab", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 s &lt;- clone(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o &lt;- seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramsortorder(s, o, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nunique &lt;- sortnut(s)[1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortordertab", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- list(values = sortorderuni(x, s, o, nunique), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   counts = sortordertab(s, o))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             p2 &lt;- sortp(p2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["ordertab", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o &lt;- seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 ramorder(x, o, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 nunique &lt;- ordernut(x, o)[1L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["ordertab", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- list(values = orderuni(x, o, nunique), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   counts = ordertab(x, o, nunique))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["ordertabkeep", "prep"] &lt;- tim["ordertab", "prep"]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["ordertabkeep", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- list(values = orderuni(x, o, nunique, keep.order = TRUE), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   counts = ordertab(x, o, nunique, keep.order = TRUE))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             p2 &lt;- sortp(p2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             hashcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["hash.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p &lt;- table.integer64(x, order = taborder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             sortordercache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sort.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- table.integer64(x, order = taborder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ordercache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["order.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- table.integer64(x, order = taborder)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (plot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 barplot(t(tim), cex.names = 0.7)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 title(paste0("table.integer64(", n, ", order=", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                   taborder, ")"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ret[["table", as.character(n)]] &lt;- tim</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if ("rank" %in% what) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         message("rank: timings of different methods")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         N &lt;- c(nsmall, nbig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (i in seq_along(N)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             n &lt;- N[i]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x &lt;- c(sample(n, n - 1L, TRUE), NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim &lt;- matrix(0, 7L, 3L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             dimnames(tim) &lt;- list(c("rank", "rank.keep", "rank.64", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "sortorderrnk", "orderrnk", "sort.cache", "order.cache"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 c("prep", "both", "use"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["rank", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 rank(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["rank.keep", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p &lt;- rank(x, na.last = "keep")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x &lt;- as.integer64(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["rank.64", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- rank.integer64(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderrnk", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 s &lt;- clone(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o &lt;- seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 na.count &lt;- ramsortorder(s, o, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortorderrnk", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- sortorderrnk(s, o, na.count)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderrnk", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o &lt;- seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 na.count &lt;- ramorder(x, o, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderrnk", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- orderrnk(x, o, na.count)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             sortordercache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sort.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- rank.integer64(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ordercache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["order.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- rank.integer64(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (plot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 barplot(t(tim), cex.names = 0.7)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 title(paste0("rank.integer64(", n, ")"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ret[["rank", as.character(n)]] &lt;- tim</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if ("quantile" %in% what) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         message("quantile: timings of different methods")</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         N &lt;- c(nsmall, nbig)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         for (i in seq_along(N)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             n &lt;- N[i]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x &lt;- c(sample(n, n - 1L, TRUE), NA)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim &lt;- matrix(0, 6L, 3L)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             dimnames(tim) &lt;- list(c("quantile", "quantile.64", </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 "sortqtl", "orderqtl", "sort.cache", "order.cache"), </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 c("prep", "both", "use"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["quantile", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p &lt;- quantile(x, type = 1L, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             p2 &lt;- p</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             p &lt;- as.integer64(p2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             names(p) &lt;- names(p2)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             x &lt;- as.integer64(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["quantile.64", "both"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- quantile(x, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortqtl", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 s &lt;- clone(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 na.count &lt;- ramsort(s, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sortqtl", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- sortqtl(s, na.count, seq(0, 1, 0.25))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(unname(p2), unname(p)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderqtl", "prep"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 o &lt;- seq_along(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 na.count &lt;- ramorder(x, o, na.last = FALSE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["orderqtl", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- orderqtl(x, o, na.count, seq(0, 1, 0.25))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(unname(p2), unname(p)))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             sortordercache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["sort.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- quantile(x, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ordercache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             tim["order.cache", "use"] &lt;- timefun({</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 p2 &lt;- quantile(x, na.rm = TRUE)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             })[3L]</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             stopifnot(identical(p2, p))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             remcache(x)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             if (plot) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 barplot(t(tim), cex.names = 0.7)</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>                 title(paste0("quantile(", n, ")"))</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>             ret[["quantile", as.character(n)]] &lt;- tim</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     ret</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> &lt;bytecode: 0x55ec07962210&gt;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> &lt;environment: namespace:bit64&gt;</span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


   </div>
  <footer><div class="container">
  <div class="pkgdown-footer-left">
  <p>Developed by Michael Chirico, Jens Oehlschlägel.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

  </div></footer></body></html>

