% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/integer64.R
\name{seq.integer64}
\alias{seq.integer64}
\title{Generating sequence of integer64 values}
\usage{
\method{seq}{integer64}(from = 1L, to = 1L, by = 1L, length.out = NULL, along.with = NULL, ...)
}
\arguments{
\item{from}{integer64 (in order to dispatch the integer64 method of \code{\link[=seq]{seq()}})}

\item{to}{scalar}

\item{by}{scalar}

\item{length.out}{scalar}

\item{along.with}{R object}

\item{...}{ignored}
}
\value{
An integer64 vector with the generated sequence
}
\description{
Generating sequence of integer64 values
}
\details{
\code{seq.integer64} coerces its arguments \code{from}, \code{to}, and \code{by} to \code{integer64}. Consistency
with \code{\link[=seq]{seq()}} is typically maintained, though results may differ when mixing \code{integer64} and
\code{double} inputs, for the same reason that any arithmetic with these mixed types can be
ambiguous. Whereas \code{seq(1L, 10L, length.out=8L)} can back up to double storage to give an
exact result, this not possible for generic inputs \code{seq(i64, dbl, length.out=n)}.
}
\examples{
seq(as.integer64(1), 12, 2)
seq(as.integer64(1), by=2, length.out=6)

# truncation rules
seq(as.integer64(1), 10, by=1.5)
seq(as.integer64(1), 10, length.out=5)
}
\seealso{
\code{\link[=c.integer64]{c.integer64()}} \code{\link[=rep.integer64]{rep.integer64()}}
\code{\link[=as.data.frame.integer64]{as.data.frame.integer64()}} \code{\link[=integer64]{integer64()}}
}
\keyword{classes}
\keyword{manip}
