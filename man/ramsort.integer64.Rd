% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sort64.R
\name{ramsort.integer64}
\alias{ramsort.integer64}
\alias{shellsort.integer64}
\alias{shellsortorder.integer64}
\alias{shellorder.integer64}
\alias{mergesort.integer64}
\alias{mergeorder.integer64}
\alias{mergesortorder.integer64}
\alias{quicksort.integer64}
\alias{quicksortorder.integer64}
\alias{quickorder.integer64}
\alias{radixsort.integer64}
\alias{radixsortorder.integer64}
\alias{radixorder.integer64}
\alias{ramsortorder.integer64}
\alias{ramorder.integer64}
\title{Low-level intger64 methods for in-RAM sorting and ordering}
\usage{
\method{shellsort}{integer64}(x, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

\method{shellsortorder}{integer64}(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

\method{shellorder}{integer64}(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

\method{mergesort}{integer64}(x, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

\method{mergeorder}{integer64}(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

\method{mergesortorder}{integer64}(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

\method{quicksort}{integer64}(
  x,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  restlevel = floor(1.5 * log2(length(x))),
  ...
)

\method{quicksortorder}{integer64}(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  restlevel = floor(1.5 * log2(length(x))),
  ...
)

\method{quickorder}{integer64}(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  restlevel = floor(1.5 * log2(length(x))),
  ...
)

\method{radixsort}{integer64}(
  x,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  radixbits = 8L,
  ...
)

\method{radixsortorder}{integer64}(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  radixbits = 8L,
  ...
)

\method{radixorder}{integer64}(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  radixbits = 8L,
  ...
)

\method{ramsort}{integer64}(
  x,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  stable = TRUE,
  optimize = c("time", "memory"),
  VERBOSE = FALSE,
  ...
)

\method{ramsortorder}{integer64}(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  stable = TRUE,
  optimize = c("time", "memory"),
  VERBOSE = FALSE,
  ...
)

\method{ramorder}{integer64}(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  stable = TRUE,
  optimize = c("time", "memory"),
  VERBOSE = FALSE,
  ...
)
}
\arguments{
\item{x}{a vector to be sorted by \code{\link[=ramsort.integer64]{ramsort.integer64()}} and
\code{\link[=ramsortorder.integer64]{ramsortorder.integer64()}}, i.e. the output of  \code{\link[=sort.integer64]{sort.integer64()}}}

\item{has.na}{boolean scalar defining whether the input vector might contain
\code{NA}s. If we know we don't have NAs, this may speed-up. \emph{Note} that you
risk a crash if there are unexpected \code{NA}s with \code{has.na=FALSE}}

\item{na.last}{boolean scalar telling ramsort whether to sort \code{NA}s last
or first. \emph{Note} that 'boolean' means that there is no third option \code{NA}
as in \code{\link[=sort]{sort()}}}

\item{decreasing}{boolean scalar telling ramsort whether to sort increasing
or decreasing}

\item{...}{further arguments, passed from generics, ignored in methods}

\item{i}{integer positions to be modified by \code{\link[=ramorder.integer64]{ramorder.integer64()}} and
\code{\link[=ramsortorder.integer64]{ramsortorder.integer64()}}, default is 1:n, in this case the output is
similar to \code{\link[=order.integer64]{order.integer64()}}}

\item{restlevel}{number of remaining recursionlevels before \code{quicksort}
switches from recursing to \code{shellsort}}

\item{radixbits}{size of radix in bits}

\item{stable}{boolean scalar defining whether stable sorting is needed.
Allowing non-stable may speed-up.}

\item{optimize}{by default ramsort optimizes for 'time' which requires more
RAM, set to 'memory' to minimize RAM requirements and sacrifice speed}

\item{VERBOSE}{cat some info about chosen method}
}
\value{
These functions return the number of \code{NAs} found or assumed
during sorting
}
\description{
Fast low-level methods for sorting and ordering. The \code{..sortorder}
methods do sorting and ordering at once, which requires more RAM
than ordering but is (almost) as fast as as sorting.
}
\details{
See \code{\link[bit:Sorting]{bit::ramsort()}}
}
\note{
Note that these methods purposely violate the functional programming
paradigm: they are called for the side-effect of changing some of
their arguments. The \code{sort}-methods change \code{x}, the \code{order}-methods
change \code{i}, and the \code{sortoder}-methods change both \code{x} and \code{i}
}
\examples{
  x <- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
  x
  message("ramsort example")
  s <- clone(x)
  ramsort(s)
  message("s has been changed in-place - whether or not ramsort uses an in-place algorithm")
  s
  message("ramorder example")
  s <- clone(x)
  o <- seq_along(s)
  ramorder(s, o)
  message("o has been changed in-place - s remains unchanged")
  s
  o
  s[o]
  message("ramsortorder example")
  o <- seq_along(s)
  ramsortorder(s, o)
  message("s and o have both been changed in-place - this is much faster")
  s
  o
}
\seealso{
\code{\link[bit:Sorting]{bit::ramsort()}} for the generic, \code{ramsort.default} for the methods
provided by package ff, \code{\link[=sort.integer64]{sort.integer64()}} for the sort interface and
\code{\link[=sortcache]{sortcache()}} for caching the work of sorting
}
\keyword{manip}
\keyword{programming}
